From 668f81b43785cd4181ffc1ca898f6301100b094f Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Wed, 9 Mar 2016 12:14:33 +0100
Subject: [PATCH 1/8] Stop accessing ssl->rbio directly.

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 dtls.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/dtls.c b/dtls.c
index 8f8c90a..4b04675 100644
--- a/dtls.c
+++ b/dtls.c
@@ -168,8 +168,8 @@ int dtlsread(SSL *ssl, struct gqueue *q, unsigned char *buf, int num, int timeou
 		rbio = getrbio(ssl, q, timeout);
 		if (!rbio)
 		    return 0;
-		BIO_free(ssl->rbio);
-		ssl->rbio = rbio;
+		BIO_free(SSL_get_rbio(ssl));
+		SSL_set_bio(ssl, rbio, SSL_get_wbio(ssl));
 		cnt = 0;
 		continue;
 	    case SSL_ERROR_WANT_WRITE:
@@ -210,9 +210,9 @@ SSL *dtlsacccon(uint8_t acc, SSL_CTX *ctx, int s, struct sockaddr *addr, struct
         if (res == 0)
             break;
         if (SSL_get_error(ssl, res) == SSL_ERROR_WANT_READ) {
-            BIO_free(ssl->rbio);
-            ssl->rbio = getrbio(ssl, rbios, 5);
-            if (!ssl->rbio)
+            BIO_free(SSL_get_rbio(ssl));
+            SSL_set_bio(ssl, getrbio(ssl, rbios, 5), SSL_get_wbio(ssl));
+            if (!SSL_get_rbio(ssl))
                 break;
         }
         while ((error = ERR_get_error()))
From eb85a9842b4dbc5769f407a7253a276afb1f1ae4 Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Wed, 9 Mar 2016 12:15:56 +0100
Subject: [PATCH 2/8] Use ERR_remove_thread_state() instead of
 ERR_remove_state().

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 dtls.c        | 6 +++---
 radsecproxy.c | 2 +-
 tls.c         | 6 +++---
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/dtls.c b/dtls.c
index 4b04675..0d8da2e 100644
--- a/dtls.c
+++ b/dtls.c
@@ -285,7 +285,7 @@ void *dtlsserverwr(void *arg) {
 		/* ssl might have changed while waiting */
 		pthread_mutex_unlock(&replyq->mutex);
 		debug(DBG_DBG, "dtlsserverwr: exiting as requested");
-		ERR_remove_state(0);
+		ERR_remove_thread_state(0);
 		pthread_exit(NULL);
 	    }
 	}
@@ -407,7 +407,7 @@ exit:
     params->sesscache->expiry.tv_sec += delay;
     pthread_mutex_unlock(&params->sesscache->mutex);
     free(params);
-    ERR_remove_state(0);
+    ERR_remove_thread_state(0);
     pthread_exit(NULL);
     debug(DBG_DBG, "dtlsservernew: exiting");
 }
@@ -664,7 +664,7 @@ void *dtlsclientrd(void *arg) {
 	}
 	replyh(server, buf);
     }
-    ERR_remove_state(0);
+    ERR_remove_thread_state(0);
     server->clientrdgone = 1;
     return NULL;
 }
diff --git a/radsecproxy.c b/radsecproxy.c
index 1590e65..7735a5c 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -1983,7 +1983,7 @@ errexit:
 	    freeclsrvconf(conf);
     }
     freeserver(server, 1);
-    ERR_remove_state(0);
+    ERR_remove_thread_state(0);
     return NULL;
 }
 
diff --git a/tls.c b/tls.c
index 38f3bb3..d127d7b 100644
--- a/tls.c
+++ b/tls.c
@@ -291,7 +291,7 @@ void *tlsclientrd(void *arg) {
 	}
     }
     debug(DBG_INFO, "tlsclientrd: exiting for %s", server->conf->name);
-    ERR_remove_state(0);
+    ERR_remove_thread_state(0);
     SSL_shutdown(server->ssl);
     shutdown(server->sock, SHUT_RDWR);
     close(server->sock);
@@ -325,7 +325,7 @@ void *tlsserverwr(void *arg) {
 		/* ssl might have changed while waiting */
 		pthread_mutex_unlock(&replyq->mutex);
 		debug(DBG_DBG, "tlsserverwr: exiting as requested");
-		ERR_remove_state(0);
+		ERR_remove_thread_state(0);
 		pthread_exit(NULL);
 	    }
 	}
@@ -451,7 +451,7 @@ exit:
 	SSL_shutdown(ssl);
 	SSL_free(ssl);
     }
-    ERR_remove_state(0);
+    ERR_remove_thread_state(0);
     shutdown(s, SHUT_RDWR);
     close(s);
     pthread_exit(NULL);
From 00a6c67786a0716749e0cbb1600dd1dbc54d693f Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Wed, 31 Aug 2016 15:49:11 +0200
Subject: [PATCH 3/8] Don't call ERR_remove_thread_state().

Not needed as of openssl-1.1, see
https://www.openssl.org/docs/man1.1.0/crypto/ERR_remove_thread_state.html

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 dtls.c        | 3 ---
 radsecproxy.c | 1 -
 tls.c         | 3 ---
 3 files changed, 7 deletions(-)

diff --git a/dtls.c b/dtls.c
index 0d8da2e..7dc9c72 100644
--- a/dtls.c
+++ b/dtls.c
@@ -285,7 +285,6 @@ void *dtlsserverwr(void *arg) {
 		/* ssl might have changed while waiting */
 		pthread_mutex_unlock(&replyq->mutex);
 		debug(DBG_DBG, "dtlsserverwr: exiting as requested");
-		ERR_remove_thread_state(0);
 		pthread_exit(NULL);
 	    }
 	}
@@ -407,7 +406,6 @@ exit:
     params->sesscache->expiry.tv_sec += delay;
     pthread_mutex_unlock(&params->sesscache->mutex);
     free(params);
-    ERR_remove_thread_state(0);
     pthread_exit(NULL);
     debug(DBG_DBG, "dtlsservernew: exiting");
 }
@@ -664,7 +662,6 @@ void *dtlsclientrd(void *arg) {
 	}
 	replyh(server, buf);
     }
-    ERR_remove_thread_state(0);
     server->clientrdgone = 1;
     return NULL;
 }
diff --git a/radsecproxy.c b/radsecproxy.c
index 7735a5c..c247d5c 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -1983,7 +1983,6 @@ errexit:
 	    freeclsrvconf(conf);
     }
     freeserver(server, 1);
-    ERR_remove_thread_state(0);
     return NULL;
 }
 
diff --git a/tls.c b/tls.c
index d127d7b..f1b0f29 100644
--- a/tls.c
+++ b/tls.c
@@ -291,7 +291,6 @@ void *tlsclientrd(void *arg) {
 	}
     }
     debug(DBG_INFO, "tlsclientrd: exiting for %s", server->conf->name);
-    ERR_remove_thread_state(0);
     SSL_shutdown(server->ssl);
     shutdown(server->sock, SHUT_RDWR);
     close(server->sock);
@@ -325,7 +324,6 @@ void *tlsserverwr(void *arg) {
 		/* ssl might have changed while waiting */
 		pthread_mutex_unlock(&replyq->mutex);
 		debug(DBG_DBG, "tlsserverwr: exiting as requested");
-		ERR_remove_thread_state(0);
 		pthread_exit(NULL);
 	    }
 	}
@@ -451,7 +449,6 @@ exit:
 	SSL_shutdown(ssl);
 	SSL_free(ssl);
     }
-    ERR_remove_thread_state(0);
     shutdown(s, SHUT_RDWR);
     close(s);
     pthread_exit(NULL);
From c206fc83904a441fa016bfe653fc20afd4cd6b8f Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Wed, 31 Aug 2016 15:58:57 +0200
Subject: [PATCH 4/8] ASN1_STRING_data() -> ASN1_STRING_get0_data().

ASN1_STRING_data was deprecated in openssl-1.1, see
https://www.openssl.org/docs/manmaster/crypto/ASN1_STRING_data.html

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 tlscommon.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/tlscommon.c b/tlscommon.c
index 157296b..843ae44 100644
--- a/tlscommon.c
+++ b/tlscommon.c
@@ -375,7 +375,7 @@ static int subjectaltnameaddr(X509 *cert, int family, struct in6_addr *addr) {
 	if (gn->type != GEN_IPADD)
 	    continue;
 	r = -1;
-	v = (char *)ASN1_STRING_data(gn->d.ia5);
+	v = (char *)ASN1_STRING_get0_data(gn->d.ia5);
 	l = ASN1_STRING_length(gn->d.ia5);
 	if (((family == AF_INET && l == sizeof(struct in_addr)) || (family == AF_INET6 && l == sizeof(struct in6_addr)))
 	    && !memcmp(v, &addr, l)) {
@@ -411,7 +411,7 @@ static int subjectaltnameregexp(X509 *cert, int type, char *exact,  regex_t *reg
 	if (gn->type != type)
 	    continue;
 	r = -1;
-	v = (char *)ASN1_STRING_data(gn->d.ia5);
+	v = (char *)ASN1_STRING_get0_data(gn->d.ia5);
 	l = ASN1_STRING_length(gn->d.ia5);
 	if (l <= 0)
 	    continue;
@@ -455,7 +455,7 @@ static int cnregexp(X509 *cert, char *exact, regex_t *regex) {
 	    break;
 	e = X509_NAME_get_entry(nm, loc);
 	t = X509_NAME_ENTRY_get_data(e);
-	v = (char *) ASN1_STRING_data(t);
+	v = (char *) ASN1_STRING_get0_data(t);
 	l = ASN1_STRING_length(t);
 	if (l < 0)
 	    continue;
From 0a522fd74cf10a86749d85dde3086ee575a56efe Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Wed, 31 Aug 2016 16:21:34 +0200
Subject: [PATCH 5/8] Remove openssl thread lock handling.

openssl-1.1 uses a new threading API which makes manual locking wrt
openssl not necessary.

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 radsecproxy.c | 25 -------------------------
 1 file changed, 25 deletions(-)

diff --git a/radsecproxy.c b/radsecproxy.c
index c247d5c..e97feae 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -77,8 +77,6 @@ static struct list *clconfs, *srvconfs;
 static struct list *realms;
 static struct hash *rewriteconfs;
 
-static pthread_mutex_t *ssl_locks = NULL;
-static long *ssl_lock_count;
 extern int optind;
 extern char *optarg;
 static const struct protodefs *protodefs[RAD_PROTOCOUNT];
@@ -104,19 +102,6 @@ uint8_t protoname2int(const char *name) {
     return 255;
 }
 
-/* callbacks for making OpenSSL thread safe */
-unsigned long ssl_thread_id() {
-    return (unsigned long)pthread_self();
-}
-
-void ssl_locking_callback(int mode, int type, const char *file, int line) {
-    if (mode & CRYPTO_LOCK) {
-	pthread_mutex_lock(&ssl_locks[type]);
-	ssl_lock_count[type]++;
-    } else
-	pthread_mutex_unlock(&ssl_locks[type]);
-}
-
 /* returns 1 if the len first bits are equal, else 0 */
 int prefixmatch(void *a1, void *a2, uint8_t len) {
     static uint8_t mask[] = { 0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };
@@ -2044,19 +2029,9 @@ void createlisteners(uint8_t type) {
 }
 
 void sslinit() {
-    int i;
     time_t t;
     pid_t pid;
 
-    ssl_locks = calloc(CRYPTO_num_locks(), sizeof(pthread_mutex_t));
-    ssl_lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i < CRYPTO_num_locks(); i++) {
-	ssl_lock_count[i] = 0;
-	pthread_mutex_init(&ssl_locks[i], NULL);
-    }
-    CRYPTO_set_id_callback(ssl_thread_id);
-    CRYPTO_set_locking_callback(ssl_locking_callback);
-
     SSL_load_error_strings();
     SSL_library_init();
 
From 759018a92fea0efc8d897dbd2e112044d19ff15b Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Thu, 1 Sep 2016 16:09:09 +0200
Subject: [PATCH 6/8] EVP_MD_CTX and HMAC_CTX are now pointers.

NOTE: pwdcrypt(), msmppencrypt(), msmppdecrypt(), _checkmsgauth(),
_validauth() _createmessageauth() and _radsign() all become slightly
more expensive since we're now allocating and freeing an EVP_MD_CTX or
HMAC_CTX on each invocation.

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 radmsg.c      |  97 ++++++++++++++++++++++++-------------------------
 radsecproxy.c | 115 +++++++++++++++++++++++++++++-----------------------------
 2 files changed, 106 insertions(+), 106 deletions(-)

diff --git a/radmsg.c b/radmsg.c
index cd01861..514d5d3 100644
--- a/radmsg.c
+++ b/radmsg.c
@@ -122,116 +122,115 @@ int radmsg_copy_attrs(struct radmsg *dst,
 }
 
 int _checkmsgauth(unsigned char *rad, uint8_t *authattr, uint8_t *secret) {
+    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static HMAC_CTX hmacctx;
+    HMAC_CTX *hmacctx = NULL;
     unsigned int md_len;
     uint8_t auth[16], hash[EVP_MAX_MD_SIZE];
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	HMAC_CTX_init(&hmacctx);
-	first = 0;
-    }
 
     memcpy(auth, authattr, 16);
     memset(authattr, 0, 16);
     md_len = 0;
-    HMAC_Init_ex(&hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
-    HMAC_Update(&hmacctx, rad, RADLEN(rad));
-    HMAC_Final(&hmacctx, hash, &md_len);
+    hmacctx = HMAC_CTX_new();
+    if (!hmacctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
+    HMAC_Init_ex(hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
+    HMAC_Update(hmacctx, rad, RADLEN(rad));
+    HMAC_Final(hmacctx, hash, &md_len);
     memcpy(authattr, auth, 16);
     if (md_len != 16) {
 	debug(DBG_WARN, "message auth computation failed");
-	pthread_mutex_unlock(&lock);
-	return 0;
+        goto out;
     }
 
     if (memcmp(auth, hash, 16)) {
 	debug(DBG_WARN, "message authenticator, wrong value");
-	pthread_mutex_unlock(&lock);
-	return 0;
+        goto out;
     }
 
+    result = 1;
+out:
+    HMAC_CTX_free(hmacctx);
     pthread_mutex_unlock(&lock);
-    return 1;
+    return result;
 }
 
 int _validauth(unsigned char *rad, unsigned char *reqauth, unsigned char *sec) {
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static EVP_MD_CTX mdctx;
+    EVP_MD_CTX *mdctx = NULL;
     unsigned char hash[EVP_MAX_MD_SIZE];
     unsigned int len;
     int result;
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	EVP_MD_CTX_init(&mdctx);
-	first = 0;
-    }
+    mdctx = EVP_MD_CTX_new();
+    if (!mdctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
     len = RADLEN(rad);
 
-    result = (EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) &&
-	      EVP_DigestUpdate(&mdctx, rad, 4) &&
-	      EVP_DigestUpdate(&mdctx, reqauth, 16) &&
-	      (len <= 20 || EVP_DigestUpdate(&mdctx, rad + 20, len - 20)) &&
-	      EVP_DigestUpdate(&mdctx, sec, strlen((char *)sec)) &&
-	      EVP_DigestFinal_ex(&mdctx, hash, &len) &&
+    result = (EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) &&
+	      EVP_DigestUpdate(mdctx, rad, 4) &&
+	      EVP_DigestUpdate(mdctx, reqauth, 16) &&
+	      (len <= 20 || EVP_DigestUpdate(mdctx, rad + 20, len - 20)) &&
+	      EVP_DigestUpdate(mdctx, sec, strlen((char *)sec)) &&
+	      EVP_DigestFinal_ex(mdctx, hash, &len) &&
 	      len == 16 &&
 	      !memcmp(hash, rad + 4, 16));
+    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
     return result;
 }
 
 int _createmessageauth(unsigned char *rad, unsigned char *authattrval, uint8_t *secret) {
+    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static HMAC_CTX hmacctx;
+    static HMAC_CTX *hmacctx = NULL;
     unsigned int md_len;
 
     if (!authattrval)
 	return 1;
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	HMAC_CTX_init(&hmacctx);
-	first = 0;
-    }
+    hmacctx = HMAC_CTX_new();
+    if (!hmacctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
     memset(authattrval, 0, 16);
     md_len = 0;
-    HMAC_Init_ex(&hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
-    HMAC_Update(&hmacctx, rad, RADLEN(rad));
-    HMAC_Final(&hmacctx, authattrval, &md_len);
+    HMAC_Init_ex(hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
+    HMAC_Update(hmacctx, rad, RADLEN(rad));
+    HMAC_Final(hmacctx, authattrval, &md_len);
     if (md_len != 16) {
 	debug(DBG_WARN, "message auth computation failed");
-	pthread_mutex_unlock(&lock);
-	return 0;
+        goto out;
     }
+    result = 1;
+out:
+    HMAC_CTX_free(hmacctx);
     pthread_mutex_unlock(&lock);
-    return 1;
+    return result;
 }
 
 int _radsign(unsigned char *rad, unsigned char *sec) {
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static EVP_MD_CTX mdctx;
+    EVP_MD_CTX *mdctx = NULL;
     unsigned int md_len;
     int result;
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	EVP_MD_CTX_init(&mdctx);
-	first = 0;
-    }
-
-    result = (EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) &&
-	      EVP_DigestUpdate(&mdctx, rad, RADLEN(rad)) &&
-	      EVP_DigestUpdate(&mdctx, sec, strlen((char *)sec)) &&
-	      EVP_DigestFinal_ex(&mdctx, rad + 4, &md_len) &&
+    mdctx = EVP_MD_CTX_new();
+    if (!mdctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
+
+    result = (EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) &&
+	      EVP_DigestUpdate(mdctx, rad, RADLEN(rad)) &&
+	      EVP_DigestUpdate(mdctx, sec, strlen((char *)sec)) &&
+	      EVP_DigestFinal_ex(mdctx, rad + 4, &md_len) &&
 	      md_len == 16);
+    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
     return result;
 }
diff --git a/radsecproxy.c b/radsecproxy.c
index e97feae..cbf3cdf 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -544,30 +544,28 @@ void sendreply(struct request *rq) {
     pthread_mutex_unlock(&to->replyq->mutex);
 }
 
-int pwdcrypt(char encrypt_flag, uint8_t *in, uint8_t len, char *shared, uint8_t sharedlen, uint8_t *auth) {
+static int pwdcrypt(char encrypt_flag, uint8_t *in, uint8_t len, char *shared, uint8_t sharedlen, uint8_t *auth) {
+    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static EVP_MD_CTX mdctx;
+    EVP_MD_CTX *mdctx = NULL;
     unsigned char hash[EVP_MAX_MD_SIZE], *input;
     unsigned int md_len;
     uint8_t i, offset = 0, out[128];
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	EVP_MD_CTX_init(&mdctx);
-	first = 0;
-    }
+    mdctx = EVP_MD_CTX_new();
+    if (!mdctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
     input = auth;
     for (;;) {
-	if (!EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(&mdctx, (uint8_t *)shared, sharedlen) ||
-	    !EVP_DigestUpdate(&mdctx, input, 16) ||
-	    !EVP_DigestFinal_ex(&mdctx, hash, &md_len) ||
+	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(mdctx, (uint8_t *)shared, sharedlen) ||
+	    !EVP_DigestUpdate(mdctx, input, 16) ||
+	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
 	    md_len != 16) {
-	    pthread_mutex_unlock(&lock);
-	    return 0;
-	}
+            goto out;
+        }
 	for (i = 0; i < 16; i++)
 	    out[offset + i] = hash[i] ^ in[offset + i];
 	if (encrypt_flag)
@@ -579,23 +577,25 @@ int pwdcrypt(char encrypt_flag, uint8_t *in, uint8_t len, char *shared, uint8_t
 	    break;
     }
     memcpy(in, out, len);
+    result = 1;
+out:
+    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
-    return 1;
+    return result;
 }
 
-int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
+static int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
+    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static EVP_MD_CTX mdctx;
+    EVP_MD_CTX *mdctx = NULL;
     unsigned char hash[EVP_MAX_MD_SIZE];
     unsigned int md_len;
     uint8_t i, offset;
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	EVP_MD_CTX_init(&mdctx);
-	first = 0;
-    }
+    mdctx = EVP_MD_CTX_new();
+    if (!mdctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
 #if 0
     printfchars(NULL, "msppencrypt auth in", "%02x ", auth, 16);
@@ -603,13 +603,12 @@ int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
     printfchars(NULL, "msppencrypt in", "%02x ", text, len);
 #endif
 
-    if (!EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) ||
-	!EVP_DigestUpdate(&mdctx, shared, sharedlen) ||
-	!EVP_DigestUpdate(&mdctx, auth, 16) ||
-	!EVP_DigestUpdate(&mdctx, salt, 2) ||
-	!EVP_DigestFinal_ex(&mdctx, hash, &md_len)) {
-	pthread_mutex_unlock(&lock);
-	return 0;
+    if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
+	!EVP_DigestUpdate(mdctx, shared, sharedlen) ||
+	!EVP_DigestUpdate(mdctx, auth, 16) ||
+	!EVP_DigestUpdate(mdctx, salt, 2) ||
+	!EVP_DigestFinal_ex(mdctx, hash, &md_len)) {
+        goto out;
     }
 
 #if 0
@@ -624,13 +623,12 @@ int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
 	printf("text + offset - 16 c(%d): ", offset / 16);
 	printfchars(NULL, NULL, "%02x ", text + offset - 16, 16);
 #endif
-	if (!EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(&mdctx, shared, sharedlen) ||
-	    !EVP_DigestUpdate(&mdctx, text + offset - 16, 16) ||
-	    !EVP_DigestFinal_ex(&mdctx, hash, &md_len) ||
+	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(mdctx, shared, sharedlen) ||
+	    !EVP_DigestUpdate(mdctx, text + offset - 16, 16) ||
+	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
 	    md_len != 16) {
-	    pthread_mutex_unlock(&lock);
-	    return 0;
+            goto out;
 	}
 #if 0
 	printfchars(NULL, "msppencrypt hash", "%02x ", hash, 16);
@@ -639,29 +637,31 @@ int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
 	for (i = 0; i < 16; i++)
 	    text[offset + i] ^= hash[i];
     }
+    result = 1;
 
 #if 0
     printfchars(NULL, "msppencrypt out", "%02x ", text, len);
 #endif
 
+out:
+    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
-    return 1;
+    return result;
 }
 
-int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
+static int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
+    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static unsigned char first = 1;
-    static EVP_MD_CTX mdctx;
+    EVP_MD_CTX *mdctx = NULL;
     unsigned char hash[EVP_MAX_MD_SIZE];
     unsigned int md_len;
     uint8_t i, offset;
     char plain[255];
 
     pthread_mutex_lock(&lock);
-    if (first) {
-	EVP_MD_CTX_init(&mdctx);
-	first = 0;
-    }
+    mdctx= EVP_MD_CTX_new();
+    if (!mdctx)
+        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
 #if 0
     printfchars(NULL, "msppdecrypt auth in", "%02x ", auth, 16);
@@ -669,13 +669,12 @@ int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
     printfchars(NULL, "msppdecrypt in", "%02x ", text, len);
 #endif
 
-    if (!EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) ||
-	!EVP_DigestUpdate(&mdctx, shared, sharedlen) ||
-	!EVP_DigestUpdate(&mdctx, auth, 16) ||
-	!EVP_DigestUpdate(&mdctx, salt, 2) ||
-	!EVP_DigestFinal_ex(&mdctx, hash, &md_len)) {
-	pthread_mutex_unlock(&lock);
-	return 0;
+    if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
+	!EVP_DigestUpdate(mdctx, shared, sharedlen) ||
+	!EVP_DigestUpdate(mdctx, auth, 16) ||
+	!EVP_DigestUpdate(mdctx, salt, 2) ||
+	!EVP_DigestFinal_ex(mdctx, hash, &md_len)) {
+        goto out;
     }
 
 #if 0
@@ -690,13 +689,12 @@ int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
 	printf("text + offset - 16 c(%d): ", offset / 16);
 	printfchars(NULL, NULL, "%02x ", text + offset - 16, 16);
 #endif
-	if (!EVP_DigestInit_ex(&mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(&mdctx, shared, sharedlen) ||
-	    !EVP_DigestUpdate(&mdctx, text + offset - 16, 16) ||
-	    !EVP_DigestFinal_ex(&mdctx, hash, &md_len) ||
+	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(mdctx, shared, sharedlen) ||
+	    !EVP_DigestUpdate(mdctx, text + offset - 16, 16) ||
+	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
 	    md_len != 16) {
-	    pthread_mutex_unlock(&lock);
-	    return 0;
+            goto out;
 	}
 #if 0
 	printfchars(NULL, "msppdecrypt hash", "%02x ", hash, 16);
@@ -707,12 +705,15 @@ int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen,
     }
 
     memcpy(text, plain, len);
+    result = 1;
 #if 0
     printfchars(NULL, "msppdecrypt out", "%02x ", text, len);
 #endif
 
+out:
+    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
-    return 1;
+    return result;
 }
 
 struct realm *newrealmref(struct realm *r) {
From f221191a52217fa30838f9eef8ac6933b4ef459f Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Tue, 13 Sep 2016 12:02:50 +0200
Subject: [PATCH 7/8] Use libnettle instead of libcrypto (from openssl) for MD5
 and HMAC(MD5).

The HMAC_ and EVP_MD_ API:s changed in OpenSSL 1.1 in a way that made
it unfeasable to support both older and newer OpenSSL.

Radsecproxy already depends on libnettle for Fticks.
Moving away from libcrypto makes it easier to add support for other
TLS libraries than OpenSSL.

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 radmsg.c      | 107 +++++++++++++++++++++-------------------------------------
 radsecproxy.c | 100 +++++++++++++++++-------------------------------------
 tlscommon.h   |   5 +++
 3 files changed, 75 insertions(+), 137 deletions(-)

diff --git a/radmsg.c b/radmsg.c
index 514d5d3..1a0f912 100644
--- a/radmsg.c
+++ b/radmsg.c
@@ -14,7 +14,7 @@
 #include "radmsg.h"
 #include "debug.h"
 #include <pthread.h>
-#include <openssl/hmac.h>
+#include <nettle/hmac.h>
 #include <openssl/rand.h>
 
 #define RADLEN(x) ntohs(((uint16_t *)(x))[1])
@@ -124,115 +124,86 @@ int radmsg_copy_attrs(struct radmsg *dst,
 int _checkmsgauth(unsigned char *rad, uint8_t *authattr, uint8_t *secret) {
     int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    HMAC_CTX *hmacctx = NULL;
-    unsigned int md_len;
-    uint8_t auth[16], hash[EVP_MAX_MD_SIZE];
+    struct hmac_md5_ctx hmacctx;
+    uint8_t auth[16], hash[MD5_DIGEST_SIZE];
 
     pthread_mutex_lock(&lock);
 
+   /* FIXME: Why clearing authattr during hashing? */
     memcpy(auth, authattr, 16);
     memset(authattr, 0, 16);
-    md_len = 0;
-    hmacctx = HMAC_CTX_new();
-    if (!hmacctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
-    HMAC_Init_ex(hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
-    HMAC_Update(hmacctx, rad, RADLEN(rad));
-    HMAC_Final(hmacctx, hash, &md_len);
+
+    hmac_md5_set_key(&hmacctx, strlen((char *) secret), secret);
+    hmac_md5_update(&hmacctx, RADLEN(rad), rad);
+    hmac_md5_digest(&hmacctx, sizeof(hash), hash);
+
     memcpy(authattr, auth, 16);
-    if (md_len != 16) {
-	debug(DBG_WARN, "message auth computation failed");
-        goto out;
-    }
 
     if (memcmp(auth, hash, 16)) {
 	debug(DBG_WARN, "message authenticator, wrong value");
         goto out;
     }
+    result = 1;                 /* Success. */
 
-    result = 1;
 out:
-    HMAC_CTX_free(hmacctx);
     pthread_mutex_unlock(&lock);
     return result;
 }
 
 int _validauth(unsigned char *rad, unsigned char *reqauth, unsigned char *sec) {
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    EVP_MD_CTX *mdctx = NULL;
-    unsigned char hash[EVP_MAX_MD_SIZE];
-    unsigned int len;
-    int result;
+    struct md5_ctx mdctx;
+    unsigned char hash[MD5_DIGEST_SIZE];
+    const unsigned int len = RADLEN(rad);
+    int result = 0;             /* Fail. */
 
     pthread_mutex_lock(&lock);
-    mdctx = EVP_MD_CTX_new();
-    if (!mdctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
-
-    len = RADLEN(rad);
-
-    result = (EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) &&
-	      EVP_DigestUpdate(mdctx, rad, 4) &&
-	      EVP_DigestUpdate(mdctx, reqauth, 16) &&
-	      (len <= 20 || EVP_DigestUpdate(mdctx, rad + 20, len - 20)) &&
-	      EVP_DigestUpdate(mdctx, sec, strlen((char *)sec)) &&
-	      EVP_DigestFinal_ex(mdctx, hash, &len) &&
-	      len == 16 &&
-	      !memcmp(hash, rad + 4, 16));
-    EVP_MD_CTX_free(mdctx);
+    md5_init(&mdctx);
+
+    md5_update(&mdctx, 4, rad);
+    md5_update(&mdctx, 16, reqauth);
+    if (len > 20)
+        md5_update(&mdctx, len - 20, rad + 20);
+    md5_update(&mdctx, strlen((char *) sec), sec);
+    md5_digest(&mdctx, sizeof(hash), hash);
+
+    result = !memcmp(hash, rad + 4, 16);
+
     pthread_mutex_unlock(&lock);
     return result;
 }
 
 int _createmessageauth(unsigned char *rad, unsigned char *authattrval, uint8_t *secret) {
-    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    static HMAC_CTX *hmacctx = NULL;
-    unsigned int md_len;
+    struct hmac_md5_ctx hmacctx;
 
     if (!authattrval)
 	return 1;
 
     pthread_mutex_lock(&lock);
-    hmacctx = HMAC_CTX_new();
-    if (!hmacctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
     memset(authattrval, 0, 16);
-    md_len = 0;
-    HMAC_Init_ex(hmacctx, secret, strlen((char *)secret), EVP_md5(), NULL);
-    HMAC_Update(hmacctx, rad, RADLEN(rad));
-    HMAC_Final(hmacctx, authattrval, &md_len);
-    if (md_len != 16) {
-	debug(DBG_WARN, "message auth computation failed");
-        goto out;
-    }
-    result = 1;
-out:
-    HMAC_CTX_free(hmacctx);
+    hmac_md5_set_key(&hmacctx, strlen((char *) secret), secret);
+    hmac_md5_update(&hmacctx, RADLEN(rad), rad);
+    hmac_md5_digest(&hmacctx, MD5_DIGEST_SIZE, authattrval);
+
     pthread_mutex_unlock(&lock);
-    return result;
+    return 1;
 }
 
 int _radsign(unsigned char *rad, unsigned char *sec) {
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    EVP_MD_CTX *mdctx = NULL;
-    unsigned int md_len;
-    int result;
+    struct md5_ctx mdctx;
 
     pthread_mutex_lock(&lock);
-    mdctx = EVP_MD_CTX_new();
-    if (!mdctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
-
-    result = (EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) &&
-	      EVP_DigestUpdate(mdctx, rad, RADLEN(rad)) &&
-	      EVP_DigestUpdate(mdctx, sec, strlen((char *)sec)) &&
-	      EVP_DigestFinal_ex(mdctx, rad + 4, &md_len) &&
-	      md_len == 16);
-    EVP_MD_CTX_free(mdctx);
+
+    md5_init(&mdctx);
+    md5_update(&mdctx, RADLEN(rad), rad);
+    md5_update(&mdctx, strlen((char *) sec), sec);
+    md5_digest(&mdctx, MD5_DIGEST_SIZE, rad + 4);
+
     pthread_mutex_unlock(&lock);
-    return result;
+    return 1;
 }
 
 uint8_t *radmsg2buf(struct radmsg *msg, uint8_t *secret) {
diff --git a/radsecproxy.c b/radsecproxy.c
index cbf3cdf..d568acd 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -58,7 +58,7 @@
 #include <openssl/ssl.h>
 #include <openssl/rand.h>
 #include <openssl/err.h>
-#include <openssl/md5.h>
+#include <nettle/md5.h>
 #include "debug.h"
 #include "hash.h"
 #include "util.h"
@@ -545,27 +545,19 @@ void sendreply(struct request *rq) {
 }
 
 static int pwdcrypt(char encrypt_flag, uint8_t *in, uint8_t len, char *shared, uint8_t sharedlen, uint8_t *auth) {
-    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    EVP_MD_CTX *mdctx = NULL;
-    unsigned char hash[EVP_MAX_MD_SIZE], *input;
-    unsigned int md_len;
+    struct md5_ctx mdctx;
+    unsigned char hash[MD5_DIGEST_SIZE], *input;
     uint8_t i, offset = 0, out[128];
 
     pthread_mutex_lock(&lock);
-    mdctx = EVP_MD_CTX_new();
-    if (!mdctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
 
+    md5_init(&mdctx);
     input = auth;
     for (;;) {
-	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(mdctx, (uint8_t *)shared, sharedlen) ||
-	    !EVP_DigestUpdate(mdctx, input, 16) ||
-	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
-	    md_len != 16) {
-            goto out;
-        }
+	md5_update(&mdctx, sharedlen, (uint8_t *) shared);
+        md5_update(&mdctx, 16, input);
+        md5_digest(&mdctx, sizeof(hash), hash);
 	for (i = 0; i < 16; i++)
 	    out[offset + i] = hash[i] ^ in[offset + i];
 	if (encrypt_flag)
@@ -577,25 +569,19 @@ static int pwdcrypt(char encrypt_flag, uint8_t *in, uint8_t len, char *shared, u
 	    break;
     }
     memcpy(in, out, len);
-    result = 1;
-out:
-    EVP_MD_CTX_free(mdctx);
+
     pthread_mutex_unlock(&lock);
-    return result;
+    return 1;
 }
 
 static int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
-    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    EVP_MD_CTX *mdctx = NULL;
-    unsigned char hash[EVP_MAX_MD_SIZE];
-    unsigned int md_len;
+    struct md5_ctx mdctx;
+    unsigned char hash[MD5_DIGEST_SIZE];
     uint8_t i, offset;
 
     pthread_mutex_lock(&lock);
-    mdctx = EVP_MD_CTX_new();
-    if (!mdctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
+    md5_init(&mdctx);
 
 #if 0
     printfchars(NULL, "msppencrypt auth in", "%02x ", auth, 16);
@@ -603,13 +589,10 @@ static int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
     printfchars(NULL, "msppencrypt in", "%02x ", text, len);
 #endif
 
-    if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
-	!EVP_DigestUpdate(mdctx, shared, sharedlen) ||
-	!EVP_DigestUpdate(mdctx, auth, 16) ||
-	!EVP_DigestUpdate(mdctx, salt, 2) ||
-	!EVP_DigestFinal_ex(mdctx, hash, &md_len)) {
-        goto out;
-    }
+    md5_update(&mdctx, sharedlen, shared);
+    md5_update(&mdctx, 16, auth);
+    md5_update(&mdctx, 2, salt);
+    md5_digest(&mdctx, sizeof(hash), hash);
 
 #if 0
     printfchars(NULL, "msppencrypt hash", "%02x ", hash, 16);
@@ -623,13 +606,9 @@ static int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
 	printf("text + offset - 16 c(%d): ", offset / 16);
 	printfchars(NULL, NULL, "%02x ", text + offset - 16, 16);
 #endif
-	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(mdctx, shared, sharedlen) ||
-	    !EVP_DigestUpdate(mdctx, text + offset - 16, 16) ||
-	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
-	    md_len != 16) {
-            goto out;
-	}
+        md5_update(&mdctx, sharedlen, shared);
+        md5_update(&mdctx, 16, text + offset - 16);
+        md5_digest(&mdctx, sizeof(hash), hash);
 #if 0
 	printfchars(NULL, "msppencrypt hash", "%02x ", hash, 16);
 #endif
@@ -637,31 +616,24 @@ static int msmppencrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
 	for (i = 0; i < 16; i++)
 	    text[offset + i] ^= hash[i];
     }
-    result = 1;
 
 #if 0
     printfchars(NULL, "msppencrypt out", "%02x ", text, len);
 #endif
 
-out:
-    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
-    return result;
+    return 1;
 }
 
 static int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sharedlen, uint8_t *auth, uint8_t *salt) {
-    int result = 0;             /* Fail. */
     static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
-    EVP_MD_CTX *mdctx = NULL;
-    unsigned char hash[EVP_MAX_MD_SIZE];
-    unsigned int md_len;
+    struct md5_ctx mdctx;
+    unsigned char hash[MD5_DIGEST_SIZE];
     uint8_t i, offset;
     char plain[255];
 
     pthread_mutex_lock(&lock);
-    mdctx= EVP_MD_CTX_new();
-    if (!mdctx)
-        debugx(1, DBG_ERR, "%s: malloc failed", __func__);
+    md5_init(&mdctx);
 
 #if 0
     printfchars(NULL, "msppdecrypt auth in", "%02x ", auth, 16);
@@ -669,13 +641,10 @@ static int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
     printfchars(NULL, "msppdecrypt in", "%02x ", text, len);
 #endif
 
-    if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
-	!EVP_DigestUpdate(mdctx, shared, sharedlen) ||
-	!EVP_DigestUpdate(mdctx, auth, 16) ||
-	!EVP_DigestUpdate(mdctx, salt, 2) ||
-	!EVP_DigestFinal_ex(mdctx, hash, &md_len)) {
-        goto out;
-    }
+    md5_update(&mdctx, sharedlen, shared);
+    md5_update(&mdctx, 16, auth);
+    md5_update(&mdctx, 2, salt);
+    md5_digest(&mdctx, sizeof(hash), hash);
 
 #if 0
     printfchars(NULL, "msppdecrypt hash", "%02x ", hash, 16);
@@ -689,13 +658,9 @@ static int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
 	printf("text + offset - 16 c(%d): ", offset / 16);
 	printfchars(NULL, NULL, "%02x ", text + offset - 16, 16);
 #endif
-	if (!EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) ||
-	    !EVP_DigestUpdate(mdctx, shared, sharedlen) ||
-	    !EVP_DigestUpdate(mdctx, text + offset - 16, 16) ||
-	    !EVP_DigestFinal_ex(mdctx, hash, &md_len) ||
-	    md_len != 16) {
-            goto out;
-	}
+        md5_update(&mdctx, sharedlen, shared);
+        md5_update(&mdctx, 16, text + offset - 16);
+        md5_digest(&mdctx, sizeof(hash), hash);
 #if 0
 	printfchars(NULL, "msppdecrypt hash", "%02x ", hash, 16);
 #endif
@@ -705,15 +670,12 @@ static int msmppdecrypt(uint8_t *text, uint8_t len, uint8_t *shared, uint8_t sha
     }
 
     memcpy(text, plain, len);
-    result = 1;
 #if 0
     printfchars(NULL, "msppdecrypt out", "%02x ", text, len);
 #endif
 
-out:
-    EVP_MD_CTX_free(mdctx);
     pthread_mutex_unlock(&lock);
-    return result;
+    return 1;
 }
 
 struct realm *newrealmref(struct realm *r) {
diff --git a/tlscommon.h b/tlscommon.h
index 4f6eadc..de990ef 100644
--- a/tlscommon.h
+++ b/tlscommon.h
@@ -3,6 +3,11 @@
 
 #include <openssl/ssl.h>
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#define ASN1_STRING_get0_data(o) ((o)->data)
+#define ASN1_STRING_length(o) ((o)->length)
+#endif
+
 struct tls {
     char *name;
     char *cacertfile;
From 6ff93d467cd5e59cfa5445baf4f615bd9c8d44a4 Mon Sep 17 00:00:00 2001
From: Linus Nordberg <linus@nordu.net>
Date: Tue, 13 Sep 2016 17:59:13 +0200
Subject: [PATCH 8/8] Require libnettle unconditionally.

Signed-off-by: Christian Hesse <mail@eworm.de>
---
 Makefile.am       | 14 +++-----------
 configure.ac      | 18 +-----------------
 debug.c           |  8 --------
 debug.h           |  2 --
 radsecproxy.c     | 14 --------------
 tests/Makefile.am |  6 +-----
 6 files changed, 5 insertions(+), 57 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index e4a6ef9..b8f75c2 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,11 +1,5 @@
 AUTOMAKE_OPTIONS = foreign
 
-if WANT_FTICKS
-fticks_sources = fticks.c fticks.h fticks_hashmac.c fticks_hashmac.h
-fticks_programs = radsecproxy-hash
-radsecproxy_hash_LDADD = fticks_hashmac.o hash.o list.o
-endif
-
 if HAVE_DOCBOOK2X_MAN
 GENMANPAGES = radsecproxy.conf.5
 endif
@@ -13,15 +7,15 @@ endif
 SUBDIRS = tests
 
 sbin_PROGRAMS = radsecproxy
-bin_PROGRAMS = radsecproxy-conf $(fticks_programs)
+bin_PROGRAMS = radsecproxy-conf radsecproxy-hash
 noinst_LIBRARIES = librsp.a
 
 radsecproxy_SOURCES = main.c
 
 librsp_a_SOURCES = \
-	$(fticks_sources) \
 	debug.c debug.h \
 	dtls.c dtls.h \
+	fticks.c fticks.h fticks_hashmac.c fticks_hashmac.h \
 	gconfig.c gconfig.h \
 	hash.c hash.h \
 	hostport.c hostport.h \
@@ -48,8 +42,8 @@ AM_CFLAGS = \
 
 radsecproxy_LDFLAGS = @SSL_LDFLAGS@ @TARGET_LDFLAGS@
 radsecproxy_LDADD = librsp.a @SSL_LIBS@
-
 radsecproxy_conf_LDFLAGS = @TARGET_LDFLAGS@
+radsecproxy_hash_LDADD = fticks_hashmac.o hash.o list.o
 
 dist_man_MANS = radsecproxy.1 radsecproxy-hash.1 $(GENMANPAGES)
 
@@ -60,8 +54,6 @@ EXTRA_DIST = \
 	radsecproxy.conf.5.xml radsecproxy.conf-example \
 	tools/README tools/naptr-eduroam.sh tools/radsec-dynsrv.sh
 
-DISTCHECK_CONFIGURE_FLAGS = --enable-fticks
-
 ####################
 radsecproxy.conf.5: $(srcdir)/radsecproxy.conf.5.xml
 	docbook2x-man $<
diff --git a/configure.ac b/configure.ac
index 307a8e7..65c3b10 100644
--- a/configure.ac
+++ b/configure.ac
@@ -53,24 +53,8 @@ AC_ARG_ENABLE(dtls,
     fi
   ])
 
-AC_ARG_ENABLE(fticks,
-AC_HELP_STRING([--enable-fticks],[build with F-Ticks support [default=no]]),
-[case $enableval in
-yes|no) ;;
-*) AC_MSG_ERROR([bad value $enableval for --enable-fticks, need yes or no]) ;;
-esac],
-[enable_fticks=no])
-
-if test "$enable_fticks" = "yes"; then
 AC_CHECK_LIB([nettle], [nettle_sha256_init],,
-    [AC_MSG_WARN([required library nettle not found, fticks support disabled])
-     enable_fticks=no])
-fi
-
-if test "$enable_fticks" = "yes"; then
-AC_DEFINE([WANT_FTICKS], [1])
-fi
-AM_CONDITIONAL(WANT_FTICKS, test "$enable_fticks" = "yes")
+    [AC_MSG_ERROR([required library nettle not found])])
 
 dnl Check if we're on Solaris and set CFLAGS accordingly
 AC_CANONICAL_SYSTEM
diff --git a/debug.c b/debug.c
index 68f0f05..ab9c662 100644
--- a/debug.c
+++ b/debug.c
@@ -23,9 +23,7 @@ static uint8_t debug_level = DBG_INFO;
 static char *debug_filepath = NULL;
 static FILE *debug_file = NULL;
 static int debug_syslogfacility = 0;
-#if defined(WANT_FTICKS)
 static int fticks_syslogfacility = 0;
-#endif
 static uint8_t debug_timestamp = 0;
 
 void debug_init(char *ident) {
@@ -104,17 +102,13 @@ int debug_set_destination(char *dest, int log_type) {
 		debugx(1, DBG_ERR, "Unknown syslog facility %s", dest);
 	    if (log_type != LOG_TYPE_FTICKS)
 		debug_syslogfacility = facvals[i];
-#if defined(WANT_FTICKS)
             else if (log_type == LOG_TYPE_FTICKS)
 		fticks_syslogfacility = facvals[i];
-#endif
 	} else {
             if (log_type != LOG_TYPE_FTICKS)
                 debug_syslogfacility = LOG_DAEMON;
-#if defined(WANT_FTICKS)
             else if (log_type == LOG_TYPE_FTICKS)
                 fticks_syslogfacility = 0;
-#endif
     	}
 	openlog(debug_ident, LOG_PID, debug_syslogfacility);
 	return 1;
@@ -231,7 +225,6 @@ void debugerrnox(int err, uint8_t level, char *format, ...) {
     exit(err);
 }
 
-#if defined(WANT_FTICKS)
 void fticks_debug(const char *format, ...) {
     int priority;
     va_list ap;
@@ -244,7 +237,6 @@ void fticks_debug(const char *format, ...) {
     	va_end(ap);
     }
 }
-#endif
 /* Local Variables: */
 /* c-file-style: "stroustrup" */
 /* End: */
diff --git a/debug.h b/debug.h
index 12cb109..83785ee 100644
--- a/debug.h
+++ b/debug.h
@@ -25,9 +25,7 @@ void debugerrno(int err, uint8_t level, char *format, ...);
 void debugerrnox(int err, uint8_t level, char *format, ...);
 int debug_set_destination(char *dest, int log_type);
 void debug_reopen_log();
-#if defined(WANT_FTICKS)
 void fticks_debug(const char *format, ...);
-#endif
 
 /* Local Variables: */
 /* c-file-style: "stroustrup" */
diff --git a/radsecproxy.c b/radsecproxy.c
index d568acd..e15ac9c 100644
--- a/radsecproxy.c
+++ b/radsecproxy.c
@@ -68,9 +68,7 @@
 #include "tcp.h"
 #include "tls.h"
 #include "dtls.h"
-#if defined(WANT_FTICKS)
 #include "fticks.h"
-#endif
 
 static struct options options;
 static struct list *clconfs, *srvconfs;
@@ -1682,11 +1680,9 @@ void replyh(struct server *server, unsigned char *buf) {
 	}
     }
 
-#if defined(WANT_FTICKS)
     if (msg->code == RAD_Access_Accept || msg->code == RAD_Access_Reject)
 	if (options.fticks_reporting && from->conf->fticks_viscountry != NULL)
 	    fticks_log(&options, from, msg, rqout);
-#endif
 
     msg->id = (char)rqout->rq->rqid;
     memcpy(msg->auth, rqout->rq->rqauth, 16);
@@ -2759,10 +2755,8 @@ int confclient_cb(struct gconffile **cf, void *arg, char *block, char *opt, char
 	    "rewriteIn", CONF_STR, &conf->confrewritein,
 	    "rewriteOut", CONF_STR, &conf->confrewriteout,
 	    "rewriteattribute", CONF_STR, &conf->confrewriteusername,
-#if defined(WANT_FTICKS)
 	    "fticksVISCOUNTRY", CONF_STR, &conf->fticks_viscountry,
 	    "fticksVISINST", CONF_STR, &conf->fticks_visinst,
-#endif
 	    NULL
 	    ))
 	debugx(1, DBG_ERR, "configuration error");
@@ -3121,11 +3115,9 @@ void getmainconfig(const char *configfile) {
     struct gconffile *cfs;
     char **listenargs[RAD_PROTOCOUNT];
     char *sourcearg[RAD_PROTOCOUNT];
-#if defined(WANT_FTICKS)
     uint8_t *fticks_reporting_str = NULL;
     uint8_t *fticks_mac_str = NULL;
     uint8_t *fticks_key_str = NULL;
-#endif
     int i;
 
     cfs = openconfigfile(configfile);
@@ -3180,12 +3172,10 @@ void getmainconfig(const char *configfile) {
 	    "TLS", CONF_CBK, conftls_cb, NULL,
 #endif
 	    "Rewrite", CONF_CBK, confrewrite_cb, NULL,
-#if defined(WANT_FTICKS)
 	    "FTicksReporting", CONF_STR, &fticks_reporting_str,
 	    "FTicksMAC", CONF_STR, &fticks_mac_str,
 	    "FTicksKey", CONF_STR, &fticks_key_str,
 	    "FTicksSyslogFacility", CONF_STR, &options.ftickssyslogfacility,
-#endif
             "IPv4Only", CONF_BLN, &options.ipv4only,
             "IPv6Only", CONF_BLN, &options.ipv6only,
 	    NULL
@@ -3205,10 +3195,8 @@ void getmainconfig(const char *configfile) {
     if (!setttlattr(&options, DEFAULT_TTL_ATTR))
     	debugx(1, DBG_ERR, "Failed to set TTLAttribute, exiting");
 
-#if defined(WANT_FTICKS)
     fticks_configure(&options, &fticks_reporting_str, &fticks_mac_str,
 		     &fticks_key_str);
-#endif
 
     for (i = 0; i < RAD_PROTOCOUNT; i++)
 	if (listenargs[i] || sourcearg[i])
@@ -3354,13 +3342,11 @@ int radsecproxy_main(int argc, char **argv) {
 	debug_set_destination(options.logdestination
                               ? options.logdestination
                               : "x-syslog:///", LOG_TYPE_DEBUG);
-#if defined(WANT_FTICKS)
     	if (options.ftickssyslogfacility) {
             debug_set_destination(options.ftickssyslogfacility,
                                   LOG_TYPE_FTICKS);
             free(options.ftickssyslogfacility);
     	}
-#endif
     }
     free(options.logdestination);
 
diff --git a/tests/Makefile.am b/tests/Makefile.am
index 2a7c339..91b037a 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -1,10 +1,6 @@
 AUTOMAKE_OPTIONS = foreign
 
-if WANT_FTICKS
-fticks_programs = t_fticks
-endif
-
-check_PROGRAMS = $(fticks_programs)
+check_PROGRAMS = t_fticks
 AM_CFLAGS = -g -Wall -Werror @TARGET_CFLAGS@
 LDADD = $(top_builddir)/librsp.a @SSL_LIBS@
 
