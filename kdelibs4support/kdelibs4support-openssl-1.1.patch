--- kdelibs4support-5.32.0/src/CMakeLists.txt.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/CMakeLists.txt	2017-03-24 14:53:43.107091847 +0100
@@ -304,6 +304,8 @@ target_include_directories(KF5KDELibs4Su
 set(platformLinkLibraries)
 if (APPLE)
     set(platformLinkLibraries "-framework CoreFoundation -framework Carbon -lresolv")
+else()
+    set(platformLinkLibraries "-lssl -lcrypto")
 endif()
 
 target_link_libraries(KF5KDELibs4Support
--- kdelibs4support-5.32.0/src/kssl/kopenssl.cpp.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/kopenssl.cpp	2017-03-24 14:56:33.956236271 +0100
@@ -22,6 +22,7 @@
 
 #if KSSL_HAVE_SSL
 #include <openssl/opensslv.h>
+#include <openssl/err.h>
 #endif
 
 #include <kconfig.h>
@@ -31,180 +32,13 @@
 #include <QtCore/QLibrary>
 #include <QtCore/QRegExp>
 
-extern "C" {
-#if KSSL_HAVE_SSL
-    static int (*K_SSL_connect)(SSL *) = nullptr;
-    static int (*K_SSL_accept)(SSL *) = nullptr;
-    static int (*K_SSL_read)(SSL *, void *, int) = nullptr;
-    static int (*K_SSL_write)(SSL *, const void *, int) = nullptr;
-    static SSL *(*K_SSL_new)(SSL_CTX *) = nullptr;
-    static void (*K_SSL_free)(SSL *) = nullptr;
-    static int (*K_SSL_shutdown)(SSL *) = nullptr;
-    static SSL_CTX *(*K_SSL_CTX_new)(SSL_METHOD *) = nullptr;
-    static void (*K_SSL_CTX_free)(SSL_CTX *) = nullptr;
-    static int (*K_SSL_set_fd)(SSL *, int) = nullptr;
-    static int (*K_SSL_pending)(SSL *) = nullptr;
-    static int (*K_SSL_peek)(SSL *, void *, int) = nullptr;
-    static int (*K_SSL_CTX_set_cipher_list)(SSL_CTX *, const char *) = nullptr;
-    static void (*K_SSL_CTX_set_verify)(SSL_CTX *, int,
-                                        int (*)(int, X509_STORE_CTX *)) = nullptr;
-    static int (*K_SSL_use_certificate)(SSL *, X509 *) = nullptr;
-    static SSL_CIPHER *(*K_SSL_get_current_cipher)(SSL *) = nullptr;
-    static long(*K_SSL_ctrl)(SSL *, int, long, char *) = nullptr;
-    static int (*K_RAND_egd)(const char *) = nullptr;
-    static const char *(*K_RAND_file_name)(char *, size_t) = nullptr;
-    static int (*K_RAND_load_file)(const char *, long) = nullptr;
-    static int (*K_RAND_write_file)(const char *) = nullptr;
-    static SSL_METHOD *(*K_TLSv1_client_method)() = nullptr;
-    static SSL_METHOD *(*K_SSLv23_client_method)() = nullptr;
-    static X509 *(*K_SSL_get_peer_certificate)(SSL *) = nullptr;
-    static int (*K_SSL_CIPHER_get_bits)(SSL_CIPHER *, int *) = nullptr;
-    static char *(*K_SSL_CIPHER_get_version)(SSL_CIPHER *) = nullptr;
-    static const char *(*K_SSL_CIPHER_get_name)(SSL_CIPHER *) = nullptr;
-    static char *(*K_SSL_CIPHER_description)(SSL_CIPHER *, char *, int) = nullptr;
-    static X509 *(*K_d2i_X509)(X509 **, unsigned char **, long) = nullptr;
-    static int (*K_i2d_X509)(X509 *, unsigned char **) = nullptr;
-    static int (*K_X509_cmp)(X509 *, X509 *) = nullptr;
-    static void (*K_X509_STORE_CTX_free)(X509_STORE_CTX *) = nullptr;
-    static int (*K_X509_verify_cert)(X509_STORE_CTX *) = nullptr;
-    static X509_STORE_CTX *(*K_X509_STORE_CTX_new)(void) = nullptr;
-    static void (*K_X509_STORE_free)(X509_STORE *) = nullptr;
-    static X509_STORE *(*K_X509_STORE_new)(void) = nullptr;
-    static void (*K_X509_free)(X509 *) = nullptr;
-    static char *(*K_X509_NAME_oneline)(X509_NAME *, char *, int) = nullptr;
-    static X509_NAME *(*K_X509_get_subject_name)(X509 *) = nullptr;
-    static X509_NAME *(*K_X509_get_issuer_name)(X509 *) = nullptr;
-    static X509_LOOKUP *(*K_X509_STORE_add_lookup)(X509_STORE *, X509_LOOKUP_METHOD *) = nullptr;
-    static X509_LOOKUP_METHOD *(*K_X509_LOOKUP_file)(void) = nullptr;
-    static void (*K_X509_LOOKUP_free)(X509_LOOKUP *) = nullptr;
-    static int (*K_X509_LOOKUP_ctrl)(X509_LOOKUP *, int, const char *, long, char **) = nullptr;
-    static void (*K_X509_STORE_CTX_init)(X509_STORE_CTX *, X509_STORE *, X509 *, STACK_OF(X509) *) = nullptr;
-    static void (*K_CRYPTO_free)(void *) = nullptr;
-    static X509 *(*K_X509_dup)(X509 *) = nullptr;
-    static BIO_METHOD *(*K_BIO_s_mem)(void) = nullptr;
-    static BIO *(*K_BIO_new)(BIO_METHOD *) = nullptr;
-    static BIO *(*K_BIO_new_fp)(FILE *, int) = nullptr;
-    static BIO *(*K_BIO_new_mem_buf)(void *, int) = nullptr;
-    static int (*K_BIO_free)(BIO *) = nullptr;
-    static long(*K_BIO_ctrl)(BIO *, int, long, void *) = nullptr;
-    static int (*K_BIO_write)(BIO *b, const void *data, int len) = nullptr;
-    static int (*K_PEM_ASN1_write_bio)(int (*)(), const char *, BIO *, char *,
-                                       const EVP_CIPHER *, unsigned char *, int,
-                                       pem_password_cb *, void *) = nullptr;
-    static int (*K_ASN1_item_i2d_fp)(ASN1_ITEM *, FILE *, unsigned char *) = nullptr;
-    static ASN1_ITEM *K_NETSCAPE_X509_it = nullptr;
-    static int (*K_X509_print_fp)(FILE *, X509 *) = nullptr;
-    static int (*K_i2d_PKCS12)(PKCS12 *, unsigned char **) = nullptr;
-    static int (*K_i2d_PKCS12_fp)(FILE *, PKCS12 *) = nullptr;
-    static int (*K_PKCS12_newpass)(PKCS12 *, char *, char *) = nullptr;
-    static PKCS12 *(*K_d2i_PKCS12_fp)(FILE *, PKCS12 **) = nullptr;
-    static PKCS12 *(*K_PKCS12_new)(void) = nullptr;
-    static void (*K_PKCS12_free)(PKCS12 *) = nullptr;
-    static int (*K_PKCS12_parse)(PKCS12 *, const char *, EVP_PKEY **,
-                                 X509 **, STACK_OF(X509) **) = nullptr;
-    static void (*K_EVP_PKEY_free)(EVP_PKEY *) = nullptr;
-    static EVP_PKEY *(*K_EVP_PKEY_new)() = nullptr;
-    static void (*K_X509_REQ_free)(X509_REQ *) = nullptr;
-    static X509_REQ *(*K_X509_REQ_new)() = nullptr;
-    static int (*K_SSL_CTX_use_PrivateKey)(SSL_CTX *, EVP_PKEY *) = nullptr;
-    static int (*K_SSL_CTX_use_certificate)(SSL_CTX *, X509 *) = nullptr;
-    static int (*K_SSL_get_error)(SSL *, int) = nullptr;
-    static STACK_OF(X509) *(*K_SSL_get_peer_cert_chain)(SSL *) = nullptr;
-    static void (*K_X509_STORE_CTX_set_chain)(X509_STORE_CTX *, STACK_OF(X509) *) = nullptr;
-    static void (*K_X509_STORE_CTX_set_purpose)(X509_STORE_CTX *, int) = nullptr;
-    static void (*K_sk_free)(STACK *) = nullptr;
-    static int (*K_sk_num)(STACK *) = nullptr;
-    static char *(*K_sk_pop)(STACK *) = nullptr;
-    static char *(*K_sk_value)(STACK *, int) = nullptr;
-    static STACK *(*K_sk_new)(int (*)()) = nullptr;
-    static int (*K_sk_push)(STACK *, char *) = nullptr;
-    static STACK *(*K_sk_dup)(STACK *) = nullptr;
-    static char *(*K_i2s_ASN1_INTEGER)(X509V3_EXT_METHOD *, ASN1_INTEGER *) = nullptr;
-    static ASN1_INTEGER *(*K_X509_get_serialNumber)(X509 *) = nullptr;
-    static EVP_PKEY *(*K_X509_get_pubkey)(X509 *) = nullptr;
-    static int (*K_i2d_PublicKey)(EVP_PKEY *, unsigned char **) = nullptr;
-    static int (*K_X509_check_private_key)(X509 *, EVP_PKEY *) = nullptr;
-    static char *(*K_BN_bn2hex)(const BIGNUM *) = nullptr;
-    static int (*K_X509_digest)(const X509 *, const EVP_MD *, unsigned char *, unsigned int *) = nullptr;
-    static EVP_MD *(*K_EVP_md5)() = nullptr;
-    static void (*K_ASN1_INTEGER_free)(ASN1_INTEGER *) = nullptr;
-    static int (*K_OBJ_obj2nid)(ASN1_OBJECT *) = nullptr;
-    static const char *(*K_OBJ_nid2ln)(int) = nullptr;
-    static int (*K_X509_get_ext_count)(X509 *) = nullptr;
-    static int (*K_X509_get_ext_by_NID)(X509 *, int, int) = nullptr;
-    static int (*K_X509_get_ext_by_OBJ)(X509 *, ASN1_OBJECT *, int) = nullptr;
-    static X509_EXTENSION *(*K_X509_get_ext)(X509 *, int loc) = nullptr;
-    static X509_EXTENSION *(*K_X509_delete_ext)(X509 *, int) = nullptr;
-    static int (*K_X509_add_ext)(X509 *, X509_EXTENSION *, int) = nullptr;
-    static void *(*K_X509_get_ext_d2i)(X509 *, int, int *, int *) = nullptr;
-    static char *(*K_i2s_ASN1_OCTET_STRING)(X509V3_EXT_METHOD *, ASN1_OCTET_STRING *) = nullptr;
-    static int (*K_ASN1_BIT_STRING_get_bit)(ASN1_BIT_STRING *, int) = nullptr;
-    static PKCS7 *(*K_PKCS7_new)() = nullptr;
-    static void (*K_PKCS7_free)(PKCS7 *) = nullptr;
-    static void (*K_PKCS7_content_free)(PKCS7 *) = nullptr;
-    static int (*K_i2d_PKCS7)(PKCS7 *, unsigned char **) = nullptr;
-    static PKCS7 *(*K_d2i_PKCS7)(PKCS7 **, unsigned char **, long) = nullptr;
-    static int (*K_i2d_PKCS7_fp)(FILE *, PKCS7 *) = nullptr;
-    static PKCS7 *(*K_d2i_PKCS7_fp)(FILE *, PKCS7 **) = nullptr;
-    static int (*K_i2d_PKCS7_bio)(BIO *bp, PKCS7 *p7) = nullptr;
-    static PKCS7 *(*K_d2i_PKCS7_bio)(BIO *bp, PKCS7 **p7) = nullptr;
-    static PKCS7 *(*K_PKCS7_dup)(PKCS7 *) = nullptr;
-    static STACK_OF(X509_NAME) *(*K_SSL_load_client_CA_file)(const char *) = nullptr;
-    static STACK_OF(X509_INFO) *(*K_PEM_X509_INFO_read)(FILE *, STACK_OF(X509_INFO) *, pem_password_cb *, void *) = nullptr;
-    static char *(*K_ASN1_d2i_fp)(char *(*)(), char *(*)(), FILE *, unsigned char **) = nullptr;
-    static X509 *(*K_X509_new)() = nullptr;
-    static int (*K_X509_PURPOSE_get_count)() = nullptr;
-    static int (*K_X509_PURPOSE_get_id)(X509_PURPOSE *) = nullptr;
-    static int (*K_X509_check_purpose)(X509 *, int, int) = nullptr;
-    static X509_PURPOSE *(*K_X509_PURPOSE_get0)(int) = nullptr;
-    static int (*K_EVP_PKEY_assign)(EVP_PKEY *, int, char *) = nullptr;
-    static int (*K_X509_REQ_set_pubkey)(X509_REQ *, EVP_PKEY *) = nullptr;
-    static RSA *(*K_RSA_generate_key)(int, unsigned long, void (*)(int, int, void *), void *) = nullptr;
-    static int (*K_i2d_X509_REQ_fp)(FILE *, X509_REQ *) = nullptr;
-    static void (*K_ERR_clear_error)() = nullptr;
-    static unsigned long(*K_ERR_get_error)() = nullptr;
-    static void (*K_ERR_print_errors_fp)(FILE *) = nullptr;
-    static PKCS7 *(*K_PKCS7_sign)(X509 *, EVP_PKEY *, STACK_OF(X509) *, BIO *, int) = nullptr;
-    static int (*K_PKCS7_verify)(PKCS7 *, STACK_OF(X509) *, X509_STORE *, BIO *, BIO *, int) = nullptr;
-    static STACK_OF(X509) *(*K_PKCS7_get0_signers)(PKCS7 *, STACK_OF(X509) *, int) = nullptr;
-    static PKCS7 *(*K_PKCS7_encrypt)(STACK_OF(X509) *, BIO *, EVP_CIPHER *, int) = nullptr;
-    static int (*K_PKCS7_decrypt)(PKCS7 *, EVP_PKEY *, X509 *, BIO *, int) = nullptr;
-    static SSL_SESSION *(*K_SSL_get1_session)(SSL *) = nullptr;
-    static void (*K_SSL_SESSION_free)(SSL_SESSION *) = nullptr;
-    static int (*K_SSL_set_session)(SSL *, SSL_SESSION *) = nullptr;
-    static SSL_SESSION *(*K_d2i_SSL_SESSION)(SSL_SESSION **, unsigned char **, long) = nullptr;
-    static int (*K_i2d_SSL_SESSION)(SSL_SESSION *, unsigned char **) = nullptr;
-    static STACK *(*K_X509_get1_email)(X509 *x) = nullptr;
-    static void (*K_X509_email_free)(STACK *sk) = nullptr;
-    static EVP_CIPHER *(*K_EVP_des_ede3_cbc)() = nullptr;
-    static EVP_CIPHER *(*K_EVP_des_cbc)() = nullptr;
-    static EVP_CIPHER *(*K_EVP_rc2_cbc)() = nullptr;
-    static EVP_CIPHER *(*K_EVP_rc2_64_cbc)() = nullptr;
-    static EVP_CIPHER *(*K_EVP_rc2_40_cbc)() = nullptr;
-    static int (*K_i2d_PrivateKey_fp)(FILE *, EVP_PKEY *) = nullptr;
-    static int (*K_i2d_PKCS8PrivateKey_fp)(FILE *, EVP_PKEY *, const EVP_CIPHER *, char *, int, pem_password_cb *, void *) = nullptr;
-    static void (*K_RSA_free)(RSA *) = nullptr;
-    static EVP_CIPHER *(*K_EVP_bf_cbc)() = nullptr;
-    static int (*K_X509_REQ_sign)(X509_REQ *, EVP_PKEY *, const EVP_MD *) = nullptr;
-    static int (*K_X509_NAME_add_entry_by_txt)(X509_NAME *, char *, int, unsigned char *, int, int, int) = nullptr;
-    static X509_NAME *(*K_X509_NAME_new)() = nullptr;
-    static int (*K_X509_REQ_set_subject_name)(X509_REQ *, X509_NAME *) = nullptr;
-    static unsigned char *(*K_ASN1_STRING_data)(ASN1_STRING *) = nullptr;
-    static int (*K_ASN1_STRING_length)(ASN1_STRING *) = nullptr;
-    static STACK_OF(SSL_CIPHER) *(*K_SSL_get_ciphers)(const SSL *ssl) = nullptr;
-
-#endif
-}
-
 class KOpenSSLProxyPrivate
 {
 public:
     KOpenSSLProxyPrivate()
-        : sslLib(nullptr), cryptoLib(nullptr), ok(false)
+        : ok(true)
     {}
 
-    QLibrary *sslLib;
-    QLibrary *cryptoLib;
     bool ok;
 
     static KOpenSSLProxy *sSelf;
@@ -217,12 +51,12 @@ KOpenSSLProxy *KOpenSSLProxyPrivate::sSe
 
 bool KOpenSSLProxy::hasLibSSL() const
 {
-    return d->sslLib != nullptr;
+    return true;
 }
 
 bool KOpenSSLProxy::hasLibCrypto() const
 {
-    return d->cryptoLib != nullptr;
+    return true;
 }
 
 void KOpenSSLProxy::destroy()
@@ -243,14 +77,14 @@ static QString findMostRecentLib(QString
     QString filter = "lib" + name + ".so.*";
     QDir d(dir, filter);
     if (!d.exists()) {
-        return 0L;
+        return nullptr;
     }
     QStringList l = d.entryList();
 
     // Find the best one
     int bestmaj = -1;
     int bestmin = -1;
-    QString best = 0L;
+    QString best = nullptr;
     // where do we start
     uint s = filter.length() - 1;
     for (QStringList::const_iterator it = l.begin(); it != l.end(); ++it) {
@@ -275,7 +109,7 @@ static QString findMostRecentLib(QString
         }
     }
     if (best.isNull()) {
-        return 0L;
+        return nullptr;
     } else {
         return dir + '/' + best;
     }
@@ -285,406 +119,10 @@ static QString findMostRecentLib(QString
 KOpenSSLProxy::KOpenSSLProxy()
     : d(new KOpenSSLProxyPrivate())
 {
-    QStringList libpaths, libnamesc, libnamess;
-
-    d->cryptoLib = nullptr;
-    d->sslLib = nullptr;
-
-    KConfig cfg("cryptodefaults", KConfig::NoGlobals);
-    KConfigGroup cg(&cfg, "OpenSSL");
-    QString upath = cg.readPathEntry("Path", QString());
-    if (!upath.isEmpty()) {
-        libpaths << upath;
-    }
-
-#ifdef Q_OS_WIN
-    d->cryptoLib = new QLibrary("libeay32.dll");
-    if (!d->cryptoLib->load()) {
-        delete d->cryptoLib;
-        d->cryptoLib = 0;
-    }
-#elif defined(__OpenBSD__)
-    {
-        QString libname = findMostRecentLib("/usr/lib" KDELIBSUFF, "crypto");
-        if (!libname.isNull()) {
-            d->cryptoLib = new QLibrary(libname);
-            d->cryptoLib->setLoadHints(QLibrary::ExportExternalSymbolsHint);
-            if (!d->cryptoLib->load()) {
-                delete d->cryptoLib;
-                d->cryptoLib = 0;
-            }
-        }
-    }
-#elif defined(__CYGWIN__)
-    libpaths << "/usr/bin/"
-             << "";
-
-    libnamess << "cygssl-0.9.8.dll"
-              << "cygssl-0.9.7.dll"
-              << "";
-
-    libnamesc << "cygcrypto-0.9.8.dll"
-              << "cygcrypto-0.9.7.dll"
-              << "";
-#else
-    libpaths
-#ifdef _AIX
-            << "/opt/freeware/lib/"
-#endif
-            << "/usr/lib" KDELIBSUFF "/"
-            << "/usr/ssl/lib" KDELIBSUFF "/"
-            << "/usr/local/lib" KDELIBSUFF "/"
-            << "/usr/local/openssl/lib" KDELIBSUFF "/"
-            << "/usr/local/ssl/lib" KDELIBSUFF "/"
-            << "/opt/openssl/lib" KDELIBSUFF "/"
-            << "/lib" KDELIBSUFF "/"
-            << "";
-
-// FIXME: #define here for the various OS types to optimize
-    libnamess
-#ifdef hpux
-            << "libssl.sl"
-#elif defined(_AIX)
-            << "libssl.a(libssl.so.0)"
-#elif defined(__APPLE__)
-            << "libssl.dylib"
-            << "libssl.0.9.dylib"
-#else
-#ifdef SHLIB_VERSION_NUMBER
-            << "libssl.so." SHLIB_VERSION_NUMBER
-#endif
-            << "libssl.so"
-            << "libssl.so.0"
-#endif
-            ;
-
-    libnamesc
-#ifdef hpux
-            << "libcrypto.sl"
-#elif defined(_AIX)
-            << "libcrypto.a(libcrypto.so.0)"
-#elif defined(__APPLE__)
-            << "libcrypto.dylib"
-            << "libcrypto.0.9.dylib"
-#else
-#ifdef SHLIB_VERSION_NUMBER
-            << "libcrypto.so." SHLIB_VERSION_NUMBER
-#endif
-            << "libcrypto.so"
-            << "libcrypto.so.0"
-#endif
-            ;
-#endif
-
-    for (QStringList::const_iterator it = libpaths.constBegin();
-            it != libpaths.constEnd();
-            ++it) {
-        for (QStringList::const_iterator shit = libnamesc.constBegin();
-                shit != libnamesc.constEnd();
-                ++shit) {
-            QString alib = *it;
-            if (!alib.isEmpty() && !alib.endsWith('/')) {
-                alib += '/';
-            }
-            alib += *shit;
-            // someone knows why this is needed?
-            QString tmpStr(alib);
-            tmpStr.remove(QRegExp("\\(.*\\)"));
-            if (QFile(tmpStr).isReadable()) {
-                d->cryptoLib = new QLibrary(alib);
-                d->cryptoLib->setLoadHints(QLibrary::ExportExternalSymbolsHint);
-            }
-            if (d->cryptoLib && d->cryptoLib->load()) {
-                break;
-            } else {
-                delete d->cryptoLib;
-                d->cryptoLib = nullptr;
-            }
-        }
-        if (d->cryptoLib) {
-            break;
-        }
-    }
-
-    if (d->cryptoLib) {
-#if KSSL_HAVE_SSL
-        K_X509_free = (void (*)(X509 *)) d->cryptoLib->resolve("X509_free");
-        K_RAND_egd = (int (*)(const char *)) d->cryptoLib->resolve("RAND_egd");
-        K_RAND_load_file = (int (*)(const char *, long)) d->cryptoLib->resolve("RAND_load_file");
-        K_RAND_file_name = (const char *(*)(char *, size_t)) d->cryptoLib->resolve("RAND_file_name");
-        K_RAND_write_file = (int (*)(const char *)) d->cryptoLib->resolve("RAND_write_file");
-        K_CRYPTO_free = (void (*)(void *)) d->cryptoLib->resolve("CRYPTO_free");
-        K_d2i_X509 = (X509 * (*)(X509 **, unsigned char **, long)) d->cryptoLib->resolve("d2i_X509");
-        K_i2d_X509 = (int (*)(X509 *, unsigned char **)) d->cryptoLib->resolve("i2d_X509");
-        K_X509_cmp = (int (*)(X509 *, X509 *)) d->cryptoLib->resolve("X509_cmp");
-        K_X509_STORE_CTX_new = (X509_STORE_CTX * (*)(void)) d->cryptoLib->resolve("X509_STORE_CTX_new");
-        K_X509_STORE_CTX_free = (void (*)(X509_STORE_CTX *)) d->cryptoLib->resolve("X509_STORE_CTX_free");
-        K_X509_verify_cert = (int (*)(X509_STORE_CTX *)) d->cryptoLib->resolve("X509_verify_cert");
-        K_X509_STORE_new = (X509_STORE * (*)(void)) d->cryptoLib->resolve("X509_STORE_new");
-        K_X509_STORE_free = (void (*)(X509_STORE *)) d->cryptoLib->resolve("X509_STORE_free");
-        K_X509_NAME_oneline = (char *(*)(X509_NAME *, char *, int)) d->cryptoLib->resolve("X509_NAME_oneline");
-        K_X509_get_subject_name = (X509_NAME * (*)(X509 *)) d->cryptoLib->resolve("X509_get_subject_name");
-        K_X509_get_issuer_name = (X509_NAME * (*)(X509 *)) d->cryptoLib->resolve("X509_get_issuer_name");
-        K_X509_STORE_add_lookup = (X509_LOOKUP * (*)(X509_STORE *, X509_LOOKUP_METHOD *)) d->cryptoLib->resolve("X509_STORE_add_lookup");
-        K_X509_LOOKUP_file = (X509_LOOKUP_METHOD * (*)(void)) d->cryptoLib->resolve("X509_LOOKUP_file");
-        K_X509_LOOKUP_free = (void (*)(X509_LOOKUP *)) d->cryptoLib->resolve("X509_LOOKUP_free");
-        K_X509_LOOKUP_ctrl = (int (*)(X509_LOOKUP *, int, const char *, long, char **)) d->cryptoLib->resolve("X509_LOOKUP_ctrl");
-        K_X509_STORE_CTX_init = (void (*)(X509_STORE_CTX *, X509_STORE *, X509 *, STACK_OF(X509) *)) d->cryptoLib->resolve("X509_STORE_CTX_init");
-        K_X509_dup = (X509 * (*)(X509 *)) d->cryptoLib->resolve("X509_dup");
-        K_BIO_s_mem = (BIO_METHOD * (*)(void)) d->cryptoLib->resolve("BIO_s_mem");
-        K_BIO_new = (BIO * (*)(BIO_METHOD *)) d->cryptoLib->resolve("BIO_new");
-        K_BIO_new_fp = (BIO * (*)(FILE *, int)) d->cryptoLib->resolve("BIO_new_fp");
-        K_BIO_new_mem_buf = (BIO * (*)(void *, int)) d->cryptoLib->resolve("BIO_new_mem_buf");
-        K_BIO_free = (int (*)(BIO *)) d->cryptoLib->resolve("BIO_free");
-        K_BIO_ctrl = (long(*)(BIO *, int, long, void *)) d->cryptoLib->resolve("BIO_ctrl");
-        K_BIO_write = (int (*)(BIO * b, const void *data, int len)) d->cryptoLib->resolve("BIO_write");
-        K_PEM_ASN1_write_bio = (int (*)(int (*)(), const char *, BIO *, char *, const EVP_CIPHER *, unsigned char *, int, pem_password_cb *, void *)) d->cryptoLib->resolve("PEM_ASN1_write_bio");
-        K_ASN1_item_i2d_fp = (int (*)(ASN1_ITEM *, FILE *, unsigned char *))
-                             d->cryptoLib->resolve("ASN1_item_i2d_fp");
-        K_NETSCAPE_X509_it = (ASN1_ITEM *) d->cryptoLib->resolve("NETSCAPE_X509_it");
-        K_X509_print_fp = (int (*)(FILE *, X509 *)) d->cryptoLib->resolve("X509_print_fp");
-        K_i2d_PKCS12 = (int (*)(PKCS12 *, unsigned char **)) d->cryptoLib->resolve("i2d_PKCS12");
-        K_i2d_PKCS12_fp = (int (*)(FILE *, PKCS12 *)) d->cryptoLib->resolve("i2d_PKCS12_fp");
-        K_PKCS12_newpass = (int (*)(PKCS12 *, char *, char *)) d->cryptoLib->resolve("PKCS12_newpass");
-        K_d2i_PKCS12_fp = (PKCS12 * (*)(FILE *, PKCS12 **)) d->cryptoLib->resolve("d2i_PKCS12_fp");
-        K_PKCS12_new = (PKCS12 * (*)()) d->cryptoLib->resolve("PKCS12_new");
-        K_PKCS12_free = (void (*)(PKCS12 *)) d->cryptoLib->resolve("PKCS12_free");
-        K_PKCS12_parse = (int (*)(PKCS12 *, const char *, EVP_PKEY **,
-                                  X509 **, STACK_OF(X509) **)) d->cryptoLib->resolve("PKCS12_parse");
-        K_EVP_PKEY_free = (void (*)(EVP_PKEY *)) d->cryptoLib->resolve("EVP_PKEY_free");
-        K_EVP_PKEY_new = (EVP_PKEY * (*)()) d->cryptoLib->resolve("EVP_PKEY_new");
-        K_X509_REQ_free = (void (*)(X509_REQ *)) d->cryptoLib->resolve("X509_REQ_free");
-        K_X509_REQ_new = (X509_REQ * (*)()) d->cryptoLib->resolve("X509_REQ_new");
-        K_X509_STORE_CTX_set_chain = (void (*)(X509_STORE_CTX *, STACK_OF(X509) *)) d->cryptoLib->resolve("X509_STORE_CTX_set_chain");
-        K_X509_STORE_CTX_set_purpose = (void (*)(X509_STORE_CTX *, int)) d->cryptoLib->resolve("X509_STORE_CTX_set_purpose");
-        K_sk_free = (void (*)(STACK *)) d->cryptoLib->resolve("sk_free");
-        K_sk_num = (int (*)(STACK *)) d->cryptoLib->resolve("sk_num");
-        K_sk_pop = (char *(*)(STACK *)) d->cryptoLib->resolve("sk_pop");
-        K_sk_value = (char *(*)(STACK *, int)) d->cryptoLib->resolve("sk_value");
-        K_sk_new = (STACK * (*)(int (*)())) d->cryptoLib->resolve("sk_new");
-        K_sk_push = (int (*)(STACK *, char *)) d->cryptoLib->resolve("sk_push");
-        K_sk_dup = (STACK * (*)(STACK *)) d->cryptoLib->resolve("sk_dup");
-        K_i2s_ASN1_INTEGER = (char *(*)(X509V3_EXT_METHOD *, ASN1_INTEGER *)) d->cryptoLib->resolve("i2s_ASN1_INTEGER");
-        K_X509_get_serialNumber = (ASN1_INTEGER * (*)(X509 *)) d->cryptoLib->resolve("X509_get_serialNumber");
-        K_X509_get_pubkey = (EVP_PKEY * (*)(X509 *)) d->cryptoLib->resolve("X509_get_pubkey");
-        K_i2d_PublicKey = (int (*)(EVP_PKEY *, unsigned char **)) d->cryptoLib->resolve("i2d_PublicKey");
-        K_X509_check_private_key = (int (*)(X509 *, EVP_PKEY *)) d->cryptoLib->resolve("X509_check_private_key");
-        K_BN_bn2hex = (char *(*)(const BIGNUM *)) d->cryptoLib->resolve("BN_bn2hex");
-        K_X509_digest = (int (*)(const X509 *, const EVP_MD *, unsigned char *, unsigned int *)) d->cryptoLib->resolve("X509_digest");
-        K_EVP_md5 = (EVP_MD * (*)()) d->cryptoLib->resolve("EVP_md5");
-        K_ASN1_INTEGER_free = (void (*)(ASN1_INTEGER *)) d->cryptoLib->resolve("ASN1_INTEGER_free");
-        K_OBJ_obj2nid = (int (*)(ASN1_OBJECT *)) d->cryptoLib->resolve("OBJ_obj2nid");
-        K_OBJ_nid2ln = (const char *(*)(int)) d->cryptoLib->resolve("OBJ_nid2ln");
-        K_X509_get_ext_count = (int (*)(X509 *)) d->cryptoLib->resolve("X509_get_ext_count");
-        K_X509_get_ext_by_NID = (int (*)(X509 *, int, int)) d->cryptoLib->resolve("X509_get_ext_by_NID");
-        K_X509_get_ext_by_OBJ = (int (*)(X509 *, ASN1_OBJECT *, int)) d->cryptoLib->resolve("X509_get_ext_by_OBJ");
-        K_X509_get_ext = (X509_EXTENSION * (*)(X509 *, int)) d->cryptoLib->resolve("X509_get_ext");
-        K_X509_delete_ext = (X509_EXTENSION * (*)(X509 *, int)) d->cryptoLib->resolve("X509_delete_ext");
-        K_X509_add_ext = (int (*)(X509 *, X509_EXTENSION *, int)) d->cryptoLib->resolve("X509_add_ext");
-        K_X509_get_ext_d2i = (void *(*)(X509 *, int, int *, int *)) d->cryptoLib->resolve("X509_get_ext_d2i");
-        K_i2s_ASN1_OCTET_STRING = (char *(*)(X509V3_EXT_METHOD *, ASN1_OCTET_STRING *)) d->cryptoLib->resolve("i2s_ASN1_OCTET_STRING");
-        K_ASN1_BIT_STRING_get_bit = (int (*)(ASN1_BIT_STRING *, int)) d->cryptoLib->resolve("ASN1_BIT_STRING_get_bit");
-        K_PKCS7_new = (PKCS7 * (*)()) d->cryptoLib->resolve("PKCS7_new");
-        K_PKCS7_free = (void (*)(PKCS7 *)) d->cryptoLib->resolve("PKCS7_free");
-        K_PKCS7_content_free = (void (*)(PKCS7 *)) d->cryptoLib->resolve("PKCS7_content_free");
-        K_i2d_PKCS7 = (int (*)(PKCS7 *, unsigned char **)) d->cryptoLib->resolve("i2d_PKCS7");
-        K_i2d_PKCS7_fp = (int (*)(FILE *, PKCS7 *)) d->cryptoLib->resolve("i2d_PKCS7_fp");
-        K_i2d_PKCS7_bio = (int (*)(BIO * bp, PKCS7 * p7)) d->cryptoLib->resolve("i2d_PKCS7_bio");
-        K_d2i_PKCS7 = (PKCS7 * (*)(PKCS7 **, unsigned char **, long)) d->cryptoLib->resolve("d2i_PKCS7");
-        K_d2i_PKCS7_fp = (PKCS7 * (*)(FILE *, PKCS7 **)) d->cryptoLib->resolve("d2i_PKCS7_fp");
-        K_d2i_PKCS7_bio = (PKCS7 * (*)(BIO * bp, PKCS7 **p7)) d->cryptoLib->resolve("d2i_PKCS7_bio");
-        K_PKCS7_dup = (PKCS7 * (*)(PKCS7 *)) d->cryptoLib->resolve("PKCS7_dup");
-        K_PKCS7_sign = (PKCS7 * (*)(X509 *, EVP_PKEY *, STACK_OF(X509) *, BIO *, int)) d->cryptoLib->resolve("PKCS7_sign");
-        K_PKCS7_verify = (int (*)(PKCS7 *, STACK_OF(X509) *, X509_STORE *, BIO *, BIO *, int)) d->cryptoLib->resolve("PKCS7_verify");
-        K_PKCS7_get0_signers = (STACK_OF(X509) * (*)(PKCS7 *, STACK_OF(X509) *, int)) d->cryptoLib->resolve("PKCS7_get0_signers");
-        K_PKCS7_encrypt = (PKCS7 * (*)(STACK_OF(X509) *, BIO *, EVP_CIPHER *, int)) d->cryptoLib->resolve("PKCS7_encrypt");
-        K_PKCS7_decrypt = (int (*)(PKCS7 *, EVP_PKEY *, X509 *, BIO *, int)) d->cryptoLib->resolve("PKCS7_decrypt");
-        K_PEM_X509_INFO_read = (STACK_OF(X509_INFO) * (*)(FILE *, STACK_OF(X509_INFO) *, pem_password_cb *, void *)) d->cryptoLib->resolve("PEM_X509_INFO_read");
-        K_ASN1_d2i_fp = (char *(*)(char *(*)(), char *(*)(), FILE *, unsigned char **)) d->cryptoLib->resolve("ASN1_d2i_fp");
-        K_X509_new = (X509 * (*)()) d->cryptoLib->resolve("X509_new");
-        K_X509_PURPOSE_get_count = (int (*)()) d->cryptoLib->resolve("X509_PURPOSE_get_count");
-        K_X509_PURPOSE_get_id = (int (*)(X509_PURPOSE *)) d->cryptoLib->resolve("X509_PURPOSE_get_id");
-        K_X509_check_purpose = (int (*)(X509 *, int, int)) d->cryptoLib->resolve("X509_check_purpose");
-        K_X509_PURPOSE_get0 = (X509_PURPOSE * (*)(int)) d->cryptoLib->resolve("X509_PURPOSE_get0");
-        K_EVP_PKEY_assign = (int (*)(EVP_PKEY *, int, char *)) d->cryptoLib->resolve("EVP_PKEY_assign");
-        K_X509_REQ_set_pubkey = (int (*)(X509_REQ *, EVP_PKEY *)) d->cryptoLib->resolve("X509_REQ_set_pubkey");
-        K_RSA_generate_key = (RSA * (*)(int, unsigned long, void (*)(int, int, void *), void *)) d->cryptoLib->resolve("RSA_generate_key");
-        K_i2d_X509_REQ_fp = (int (*)(FILE *, X509_REQ *)) d->cryptoLib->resolve("i2d_X509_REQ_fp");
-        K_ERR_clear_error = (void (*)()) d->cryptoLib->resolve("ERR_clear_error");
-        K_ERR_get_error = (unsigned long(*)()) d->cryptoLib->resolve("ERR_get_error");
-        K_ERR_print_errors_fp = (void (*)(FILE *)) d->cryptoLib->resolve("ERR_print_errors_fp");
-        K_X509_get1_email = (STACK * (*)(X509 * x)) d->cryptoLib->resolve("X509_get1_email");
-        K_X509_email_free = (void (*)(STACK * sk)) d->cryptoLib->resolve("X509_email_free");
-        K_EVP_des_ede3_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_des_ede3_cbc");
-        K_EVP_des_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_des_cbc");
-        K_EVP_rc2_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_rc2_cbc");
-        K_EVP_rc2_64_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_rc2_64_cbc");
-        K_EVP_rc2_40_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_rc2_40_cbc");
-        K_i2d_PrivateKey_fp = (int (*)(FILE *, EVP_PKEY *)) d->cryptoLib->resolve("i2d_PrivateKey_fp");
-        K_i2d_PKCS8PrivateKey_fp = (int (*)(FILE *, EVP_PKEY *, const EVP_CIPHER *, char *, int, pem_password_cb *, void *)) d->cryptoLib->resolve("i2d_PKCS8PrivateKey_fp");
-        K_RSA_free = (void (*)(RSA *)) d->cryptoLib->resolve("RSA_free");
-        K_EVP_bf_cbc = (EVP_CIPHER * (*)()) d->cryptoLib->resolve("EVP_bf_cbc");
-        K_X509_REQ_sign = (int (*)(X509_REQ *, EVP_PKEY *, const EVP_MD *)) d->cryptoLib->resolve("X509_REQ_sign");
-        K_X509_NAME_add_entry_by_txt = (int (*)(X509_NAME *, char *, int, unsigned char *, int, int, int)) d->cryptoLib->resolve("X509_NAME_add_entry_by_txt");
-        K_X509_NAME_new = (X509_NAME * (*)()) d->cryptoLib->resolve("X509_NAME_new");
-        K_X509_REQ_set_subject_name = (int (*)(X509_REQ *, X509_NAME *)) d->cryptoLib->resolve("X509_REQ_set_subject_name");
-        K_ASN1_STRING_data = (unsigned char *(*)(ASN1_STRING *)) d->cryptoLib->resolve("ASN1_STRING_data");
-        K_ASN1_STRING_length = (int (*)(ASN1_STRING *)) d->cryptoLib->resolve("ASN1_STRING_length");
-#endif
-    }
-
-#ifdef Q_OS_WIN
-    d->sslLib = new QLibrary("ssleay32.dll");
-    if (!d->sslLib->load()) {
-        delete d->sslLib;
-        d->sslLib = 0;
-    }
-#elif defined(__OpenBSD__)
-    {
-        QString libname = findMostRecentLib("/usr/lib", "ssl");
-        if (!libname.isNull()) {
-            d->sslLib = new QLibrary(libname);
-            d->sslLib->setLoadHints(QLibrary::ExportExternalSymbolsHint);
-            if (!d->sslLib->load()) {
-                delete d->sslLib;
-                d->sslLib = 0;
-            }
-        }
-    }
-#else
-    for (QStringList::const_iterator it = libpaths.constBegin();
-            it != libpaths.constEnd();
-            ++it) {
-        for (QStringList::const_iterator shit = libnamess.constBegin();
-                shit != libnamess.constEnd();
-                ++shit) {
-            QString alib = *it;
-            if (!alib.isEmpty() && !alib.endsWith('/')) {
-                alib += '/';
-            }
-            alib += *shit;
-            QString tmpStr(alib);
-            tmpStr.remove(QRegExp("\\(.*\\)"));
-            if (QFile(tmpStr).isReadable()) {
-                d->sslLib = new QLibrary(alib);
-                d->sslLib->setLoadHints(QLibrary::ExportExternalSymbolsHint);
-            }
-            if (d->sslLib && d->sslLib->load()) {
-                break;
-            } else {
-                delete d->sslLib;
-                d->sslLib = nullptr;
-            }
-        }
-        if (d->sslLib) {
-            break;
-        }
-    }
-#endif
-
-    if (d->sslLib) {
-#if KSSL_HAVE_SSL
-        // stand back from your monitor and look at this.  it's fun! :)
-        K_SSL_connect = (int (*)(SSL *)) d->sslLib->resolve("SSL_connect");
-        K_SSL_accept = (int (*)(SSL *)) d->sslLib->resolve("SSL_accept");
-        K_SSL_read = (int (*)(SSL *, void *, int)) d->sslLib->resolve("SSL_read");
-        K_SSL_write = (int (*)(SSL *, const void *, int))
-                      d->sslLib->resolve("SSL_write");
-        K_SSL_new = (SSL * (*)(SSL_CTX *)) d->sslLib->resolve("SSL_new");
-        K_SSL_free = (void (*)(SSL *)) d->sslLib->resolve("SSL_free");
-        K_SSL_shutdown = (int (*)(SSL *)) d->sslLib->resolve("SSL_shutdown");
-        K_SSL_CTX_new = (SSL_CTX * (*)(SSL_METHOD *)) d->sslLib->resolve("SSL_CTX_new");
-        K_SSL_CTX_free = (void (*)(SSL_CTX *)) d->sslLib->resolve("SSL_CTX_free");
-        K_SSL_set_fd = (int (*)(SSL *, int)) d->sslLib->resolve("SSL_set_fd");
-        K_SSL_pending = (int (*)(SSL *)) d->sslLib->resolve("SSL_pending");
-        K_SSL_CTX_set_cipher_list = (int (*)(SSL_CTX *, const char *))
-                                    d->sslLib->resolve("SSL_CTX_set_cipher_list");
-        K_SSL_CTX_set_verify = (void (*)(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *))) d->sslLib->resolve("SSL_CTX_set_verify");
-        K_SSL_use_certificate = (int (*)(SSL *, X509 *))
-                                d->sslLib->resolve("SSL_CTX_use_certificate");
-        K_SSL_get_current_cipher = (SSL_CIPHER * (*)(SSL *))
-                                   d->sslLib->resolve("SSL_get_current_cipher");
-        K_SSL_ctrl = (long(*)(SSL *, int, long, char *))
-                     d->sslLib->resolve("SSL_ctrl");
-        K_TLSv1_client_method = (SSL_METHOD * (*)()) d->sslLib->resolve("TLSv1_client_method");
-        K_SSLv23_client_method = (SSL_METHOD * (*)()) d->sslLib->resolve("SSLv23_client_method");
-        K_SSL_get_peer_certificate = (X509 * (*)(SSL *)) d->sslLib->resolve("SSL_get_peer_certificate");
-        K_SSL_CIPHER_get_bits = (int (*)(SSL_CIPHER *, int *)) d->sslLib->resolve("SSL_CIPHER_get_bits");
-        K_SSL_CIPHER_get_version = (char *(*)(SSL_CIPHER *)) d->sslLib->resolve("SSL_CIPHER_get_version");
-        K_SSL_CIPHER_get_name = (const char *(*)(SSL_CIPHER *)) d->sslLib->resolve("SSL_CIPHER_get_name");
-        K_SSL_CIPHER_description = (char *(*)(SSL_CIPHER *, char *, int)) d->sslLib->resolve("SSL_CIPHER_description");
-        K_SSL_CTX_use_PrivateKey = (int (*)(SSL_CTX *, EVP_PKEY *)) d->sslLib->resolve("SSL_CTX_use_PrivateKey");
-        K_SSL_CTX_use_certificate = (int (*)(SSL_CTX *, X509 *)) d->sslLib->resolve("SSL_CTX_use_certificate");
-        K_SSL_get_error = (int (*)(SSL *, int)) d->sslLib->resolve("SSL_get_error");
-        K_SSL_get_peer_cert_chain = (STACK_OF(X509) * (*)(SSL *)) d->sslLib->resolve("SSL_get_peer_cert_chain");
-        K_SSL_load_client_CA_file = (STACK_OF(X509_NAME) * (*)(const char *)) d->sslLib->resolve("SSL_load_client_CA_file");
-        K_SSL_peek = (int (*)(SSL *, void *, int)) d->sslLib->resolve("SSL_peek");
-        K_SSL_get1_session = (SSL_SESSION * (*)(SSL *)) d->sslLib->resolve("SSL_get1_session");
-        K_SSL_SESSION_free = (void (*)(SSL_SESSION *)) d->sslLib->resolve("SSL_SESSION_free");
-        K_SSL_set_session = (int (*)(SSL *, SSL_SESSION *)) d->sslLib->resolve("SSL_set_session");
-        K_d2i_SSL_SESSION = (SSL_SESSION * (*)(SSL_SESSION **, unsigned char **, long)) d->sslLib->resolve("d2i_SSL_SESSION");
-        K_i2d_SSL_SESSION = (int (*)(SSL_SESSION *, unsigned char **)) d->sslLib->resolve("i2d_SSL_SESSION");
-        K_SSL_get_ciphers = (STACK_OF(SSL_CIPHER) * (*)(const SSL *)) d->sslLib->resolve("SSL_get_ciphers");
-#endif
-
-        // Initialize the library (once only!)
-        QFunctionPointer x;
-        x = d->sslLib->resolve("SSL_library_init");
-        if (d->cryptoLib) {
-            if (x) {
-                ((int (*)())x)();
-            }
-            x = d->cryptoLib->resolve("OpenSSL_add_all_algorithms");
-            if (!x) {
-                x = d->cryptoLib->resolve("OPENSSL_add_all_algorithms");
-            }
-            if (x) {
-                ((void (*)())x)();
-            } else {
-                x = d->cryptoLib->resolve("OpenSSL_add_all_algorithms_conf");
-                if (!x) {
-                    x = d->cryptoLib->resolve("OPENSSL_add_all_algorithms_conf");
-                }
-                if (x) {
-                    ((void (*)())x)();
-                } else {
-                    x = d->cryptoLib->resolve("OpenSSL_add_all_algorithms_noconf");
-                    if (!x) {
-                        x = d->cryptoLib->resolve("OPENSSL_add_all_algorithms_noconf");
-                    }
-                    if (x) {
-                        ((void (*)())x)();
-                    }
-                }
-            }
-            x = d->cryptoLib->resolve("OpenSSL_add_all_ciphers");
-            if (!x) {
-                x = d->cryptoLib->resolve("OPENSSL_add_all_ciphers");
-            }
-            if (x) {
-                ((void (*)())x)();
-            }
-            x = d->cryptoLib->resolve("OpenSSL_add_all_digests");
-            if (!x) {
-                x = d->cryptoLib->resolve("OPENSSL_add_all_digests");
-            }
-            if (x) {
-                ((void (*)())x)();
-            }
-        }
-    }
-
 }
 
 KOpenSSLProxy::~KOpenSSLProxy()
 {
-    if (d->sslLib) {
-        d->sslLib->unload();
-    }
-    if (d->cryptoLib) {
-        d->cryptoLib->unload();
-    }
-
     KOpenSSLProxyPrivate::sSelf = nullptr;
     delete d;
 }
@@ -706,1293 +144,771 @@ KOpenSSLProxy *KOpenSSLProxy::self()
 
 int KOpenSSLProxy::SSL_connect(SSL *ssl)
 {
-    if (K_SSL_connect) {
-        return (K_SSL_connect)(ssl);
-    }
-    return -1;
+    return ::SSL_connect(ssl);
 }
 
 int KOpenSSLProxy::SSL_accept(SSL *ssl)
 {
-    if (K_SSL_accept) {
-        return (K_SSL_accept)(ssl);
-    }
-    return -1;
+    return ::SSL_accept(ssl);
 }
 
 int KOpenSSLProxy::SSL_read(SSL *ssl, void *buf, int num)
 {
-    if (K_SSL_read) {
-        return (K_SSL_read)(ssl, buf, num);
-    }
-    return -1;
+    return ::SSL_read(ssl, buf, num);
 }
 
 int KOpenSSLProxy::SSL_write(SSL *ssl, const void *buf, int num)
 {
-    if (K_SSL_write) {
-        return (K_SSL_write)(ssl, buf, num);
-    }
-    return -1;
+    return ::SSL_write(ssl, buf, num);
 }
 
 SSL *KOpenSSLProxy::SSL_new(SSL_CTX *ctx)
 {
-    if (K_SSL_new) {
-        return (K_SSL_new)(ctx);
-    }
-    return nullptr;
+    return ::SSL_new(ctx);
 }
 
 void KOpenSSLProxy::SSL_free(SSL *ssl)
 {
-    if (K_SSL_free) {
-        (K_SSL_free)(ssl);
-    }
+    return ::SSL_free(ssl);
 }
 
 int KOpenSSLProxy::SSL_shutdown(SSL *ssl)
 {
-    if (K_SSL_shutdown) {
-        return (K_SSL_shutdown)(ssl);
-    }
-    return -1;
+    return ::SSL_shutdown(ssl);
 }
 
-SSL_CTX *KOpenSSLProxy::SSL_CTX_new(SSL_METHOD *method)
+SSL_CTX *KOpenSSLProxy::SSL_CTX_new(const SSL_METHOD *method)
 {
-    if (K_SSL_CTX_new) {
-        return (K_SSL_CTX_new)(method);
-    }
-    return nullptr;
+    return ::SSL_CTX_new(method);
 }
 
 void KOpenSSLProxy::SSL_CTX_free(SSL_CTX *ctx)
 {
-    if (K_SSL_CTX_free) {
-        (K_SSL_CTX_free)(ctx);
-    }
+    return ::SSL_CTX_free(ctx);
 }
 
 int KOpenSSLProxy::SSL_set_fd(SSL *ssl, int fd)
 {
-    if (K_SSL_set_fd) {
-        return (K_SSL_set_fd)(ssl, fd);
-    }
-    return -1;
+    return ::SSL_set_fd(ssl, fd);
 }
 
 int KOpenSSLProxy::SSL_pending(SSL *ssl)
 {
-    if (K_SSL_pending) {
-        return (K_SSL_pending)(ssl);
-    }
-    return -1;
+    return ::SSL_pending(ssl);
 }
 
 int KOpenSSLProxy::SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)
 {
-    if (K_SSL_CTX_set_cipher_list) {
-        return (K_SSL_CTX_set_cipher_list)(ctx, str);
-    }
-    return -1;
+    return ::SSL_CTX_set_cipher_list(ctx, str);
 }
 
 void KOpenSSLProxy::SSL_CTX_set_verify(SSL_CTX *ctx, int mode,
                                        int (*verify_callback)(int, X509_STORE_CTX *))
 {
-    if (K_SSL_CTX_set_verify) {
-        (K_SSL_CTX_set_verify)(ctx, mode, verify_callback);
-    }
+    ::SSL_CTX_set_verify(ctx, mode, verify_callback);
 }
 
 int KOpenSSLProxy::SSL_use_certificate(SSL *ssl, X509 *x)
 {
-    if (K_SSL_use_certificate) {
-        return (K_SSL_use_certificate)(ssl, x);
-    }
-    return -1;
+    return ::SSL_use_certificate(ssl, x);
 }
 
-SSL_CIPHER *KOpenSSLProxy::SSL_get_current_cipher(SSL *ssl)
+const SSL_CIPHER *KOpenSSLProxy::SSL_get_current_cipher(SSL *ssl)
 {
-    if (K_SSL_get_current_cipher) {
-        return (K_SSL_get_current_cipher)(ssl);
-    }
-    return nullptr;
+    return ::SSL_get_current_cipher(ssl);
 }
 
 long KOpenSSLProxy::SSL_ctrl(SSL *ssl, int cmd, long larg, char *parg)
 {
-    if (K_SSL_ctrl) {
-        return (K_SSL_ctrl)(ssl, cmd, larg, parg);
-    }
-    return -1;
+    return ::SSL_ctrl(ssl, cmd, larg, parg);
 }
 
 int KOpenSSLProxy::RAND_egd(const char *path)
 {
-    if (K_RAND_egd) {
-        return (K_RAND_egd)(path);
-    }
-    return -1;
+#ifndef OPENSSL_NO_EGD
+    return ::RAND_egd(path);
+#endif
+    return 0;
 }
 
-SSL_METHOD *KOpenSSLProxy::TLSv1_client_method()
+const SSL_METHOD *KOpenSSLProxy::TLSv1_client_method()
 {
-    if (K_TLSv1_client_method) {
-        return (K_TLSv1_client_method)();
-    }
-    return nullptr;
+    return ::TLSv1_client_method();
 }
 
-SSL_METHOD *KOpenSSLProxy::SSLv23_client_method()
+const SSL_METHOD *KOpenSSLProxy::SSLv23_client_method()
 {
-    if (K_SSLv23_client_method) {
-        return (K_SSLv23_client_method)();
-    }
-    return nullptr;
+    return ::SSLv23_client_method();
 }
 
 X509 *KOpenSSLProxy::SSL_get_peer_certificate(SSL *s)
 {
-    if (K_SSL_get_peer_certificate) {
-        return (K_SSL_get_peer_certificate)(s);
-    }
-    return nullptr;
+    return ::SSL_get_peer_certificate(s);
 }
 
 int KOpenSSLProxy::SSL_CIPHER_get_bits(SSL_CIPHER *c, int *alg_bits)
 {
-    if (K_SSL_CIPHER_get_bits) {
-        return (K_SSL_CIPHER_get_bits)(c, alg_bits);
-    }
-    return -1;
+    return ::SSL_CIPHER_get_bits(c, alg_bits);
 }
 
-char *KOpenSSLProxy::SSL_CIPHER_get_version(SSL_CIPHER *c)
+const char *KOpenSSLProxy::SSL_CIPHER_get_version(SSL_CIPHER *c)
 {
-    if (K_SSL_CIPHER_get_version) {
-        return (K_SSL_CIPHER_get_version)(c);
-    }
-    return nullptr;
+    return ::SSL_CIPHER_get_version(c);
 }
 
 const char *KOpenSSLProxy::SSL_CIPHER_get_name(SSL_CIPHER *c)
 {
-    if (K_SSL_CIPHER_get_name) {
-        return (K_SSL_CIPHER_get_name)(c);
-    }
-    return nullptr;
+    return ::SSL_CIPHER_get_name(c);
 }
 
 char *KOpenSSLProxy::SSL_CIPHER_description(SSL_CIPHER *c, char *buf, int size)
 {
-    if (K_SSL_CIPHER_description) {
-        return (K_SSL_CIPHER_description)(c, buf, size);
-    }
-    return nullptr;
+    return ::SSL_CIPHER_description(c, buf, size);
 }
 
-X509 *KOpenSSLProxy::d2i_X509(X509 **a, unsigned char **pp, long length)
+X509 *KOpenSSLProxy::d2i_X509(X509 **a, const unsigned char **pp, long length)
 {
-    if (K_d2i_X509) {
-        return (K_d2i_X509)(a, pp, length);
-    }
-    return nullptr;
+    return ::d2i_X509(a, pp, length);
 }
 
 int KOpenSSLProxy::i2d_X509(X509 *a, unsigned char **pp)
 {
-    if (K_i2d_X509) {
-        return (K_i2d_X509)(a, pp);
-    }
-    return -1;
+    return ::i2d_X509(a, pp);
 }
 
 int KOpenSSLProxy::X509_cmp(X509 *a, X509 *b)
 {
-    if (K_X509_cmp) {
-        return (K_X509_cmp)(a, b);
-    }
-    return 0;
+    return ::X509_cmp(a, b);
 }
 
 X509_STORE *KOpenSSLProxy::X509_STORE_new(void)
 {
-    if (K_X509_STORE_new) {
-        return (K_X509_STORE_new)();
-    }
-    return nullptr;
+    return ::X509_STORE_new();
 }
 
 void KOpenSSLProxy::X509_STORE_free(X509_STORE *v)
 {
-    if (K_X509_STORE_free) {
-        (K_X509_STORE_free)(v);
-    }
+    ::X509_STORE_free(v);
 }
 
 X509_STORE_CTX *KOpenSSLProxy::X509_STORE_CTX_new(void)
 {
-    if (K_X509_STORE_CTX_new) {
-        return (K_X509_STORE_CTX_new)();
-    }
-    return nullptr;
+    return ::X509_STORE_CTX_new();
 }
 
 void KOpenSSLProxy::X509_STORE_CTX_free(X509_STORE_CTX *ctx)
 {
-    if (K_X509_STORE_CTX_free) {
-        (K_X509_STORE_CTX_free)(ctx);
-    }
+    ::X509_STORE_CTX_free(ctx);
 }
 
 int KOpenSSLProxy::X509_verify_cert(X509_STORE_CTX *ctx)
 {
-    if (K_X509_verify_cert) {
-        return (K_X509_verify_cert)(ctx);
-    }
-    return -1;
+    return ::X509_verify_cert(ctx);
 }
 
 void KOpenSSLProxy::X509_free(X509 *a)
 {
-    if (K_X509_free) {
-        (K_X509_free)(a);
-    }
+    ::X509_free(a);
 }
 
 char *KOpenSSLProxy::X509_NAME_oneline(X509_NAME *a, char *buf, int size)
 {
-    if (K_X509_NAME_oneline) {
-        return (K_X509_NAME_oneline)(a, buf, size);
-    }
-    return nullptr;
+    return ::X509_NAME_oneline(a, buf, size);
 }
 
 X509_NAME *KOpenSSLProxy::X509_get_subject_name(X509 *a)
 {
-    if (K_X509_get_subject_name) {
-        return (K_X509_get_subject_name)(a);
-    }
-    return nullptr;
+    return ::X509_get_subject_name(a);
 }
 
 X509_NAME *KOpenSSLProxy::X509_get_issuer_name(X509 *a)
 {
-    if (K_X509_get_issuer_name) {
-        return (K_X509_get_issuer_name)(a);
-    }
-    return nullptr;
+    return ::X509_get_issuer_name(a);
 }
 
 X509_LOOKUP *KOpenSSLProxy::X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
 {
-    if (K_X509_STORE_add_lookup) {
-        return (K_X509_STORE_add_lookup)(v, m);
-    }
-    return nullptr;
+    return ::X509_STORE_add_lookup(v, m);
 }
 
 X509_LOOKUP_METHOD *KOpenSSLProxy::X509_LOOKUP_file(void)
 {
-    if (K_X509_LOOKUP_file) {
-        return (K_X509_LOOKUP_file)();
-    }
-    return nullptr;
+    return ::X509_LOOKUP_file();
 }
 
 void KOpenSSLProxy::X509_LOOKUP_free(X509_LOOKUP *x)
 {
-    if (K_X509_LOOKUP_free) {
-        (K_X509_LOOKUP_free)(x);
-    }
+    ::X509_LOOKUP_free(x);
 }
 
 int KOpenSSLProxy::X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl, char **ret)
 {
-    if (K_X509_LOOKUP_ctrl) {
-        return (K_X509_LOOKUP_ctrl)(ctx, cmd, argc, argl, ret);
-    }
-    return -1;
+    return ::X509_LOOKUP_ctrl(ctx, cmd, argc, argl, ret);
 }
 
 void KOpenSSLProxy::X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509, STACK_OF(X509) *chain)
 {
-    if (K_X509_STORE_CTX_init) {
-        (K_X509_STORE_CTX_init)(ctx, store, x509, chain);
-    }
+    ::X509_STORE_CTX_init(ctx, store, x509, chain);
 }
 
 void KOpenSSLProxy::CRYPTO_free(void *x)
 {
-    if (K_CRYPTO_free) {
-        (K_CRYPTO_free)(x);
-    }
+    ::CRYPTO_free(x, OPENSSL_FILE, OPENSSL_LINE);
 }
 
 X509 *KOpenSSLProxy::X509_dup(X509 *x509)
 {
-    if (K_X509_dup) {
-        return (K_X509_dup)(x509);
-    }
-    return nullptr;
+    return ::X509_dup(x509);
 }
 
 BIO *KOpenSSLProxy::BIO_new(BIO_METHOD *type)
 {
-    if (K_BIO_new) {
-        return (K_BIO_new)(type);
-    } else {
-        return nullptr;
-    }
+    return ::BIO_new(type);
 }
 
-BIO_METHOD *KOpenSSLProxy::BIO_s_mem(void)
+const BIO_METHOD *KOpenSSLProxy::BIO_s_mem(void)
 {
-    if (K_BIO_s_mem) {
-        return (K_BIO_s_mem)();
-    } else {
-        return nullptr;
-    }
+    return ::BIO_s_mem();
 }
 
 BIO *KOpenSSLProxy::BIO_new_fp(FILE *stream, int close_flag)
 {
-    if (K_BIO_new_fp) {
-        return (K_BIO_new_fp)(stream, close_flag);
-    }
-    return nullptr;
+    return ::BIO_new_fp(stream, close_flag);
 }
 
 BIO *KOpenSSLProxy::BIO_new_mem_buf(void *buf, int len)
 {
-    if (K_BIO_new_mem_buf) {
-        return (K_BIO_new_mem_buf)(buf, len);
-    } else {
-        return nullptr;
-    }
+    return ::BIO_new_mem_buf(buf, len);
 }
 
 int KOpenSSLProxy::BIO_free(BIO *a)
 {
-    if (K_BIO_free) {
-        return (K_BIO_free)(a);
-    }
-    return -1;
+    return ::BIO_free(a);
 }
 
 long KOpenSSLProxy::BIO_ctrl(BIO *bp, int cmd, long larg, void *parg)
 {
-    if (K_BIO_ctrl) {
-        return (K_BIO_ctrl)(bp, cmd, larg, parg);
-    } else {
-        return 0;    // failure return for BIO_ctrl is quite individual, maybe we should abort() instead
-    }
+    return ::BIO_ctrl(bp, cmd, larg, parg);
 }
 
 int KOpenSSLProxy::BIO_write(BIO *b, const void *data, int len)
 {
-    if (K_BIO_write) {
-        return (K_BIO_write)(b, data, len);
-    } else {
-        return -1;
-    }
+    return ::BIO_write(b, data, len);
 }
 
 int KOpenSSLProxy::PEM_write_bio_X509(BIO *bp, X509 *x)
 {
-    if (K_PEM_ASN1_write_bio) {
-        return (K_PEM_ASN1_write_bio)((int (*)())K_i2d_X509, PEM_STRING_X509, bp, (char *)x, nullptr, nullptr, 0, nullptr, nullptr);
-    } else {
-        return -1;
-    }
-}
-
-int KOpenSSLProxy::ASN1_item_i2d_fp(FILE *out, unsigned char *x)
-{
-    if (K_ASN1_item_i2d_fp && K_NETSCAPE_X509_it) {
-        return (K_ASN1_item_i2d_fp)(K_NETSCAPE_X509_it, out, x);
-    } else {
-        return -1;
-    }
+    return ::PEM_ASN1_write_bio(reinterpret_cast<i2d_of_void*>(::i2d_X509), PEM_STRING_X509, bp, (char *)x, nullptr, nullptr, 0, nullptr, nullptr);
 }
 
 int KOpenSSLProxy::X509_print(FILE *fp, X509 *x)
 {
-    if (K_X509_print_fp) {
-        return (K_X509_print_fp)(fp, x);
-    }
-    return -1;
+    return ::X509_print_fp(fp, x);
 }
 
 PKCS12 *KOpenSSLProxy::d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)
 {
-    if (K_d2i_PKCS12_fp) {
-        return (K_d2i_PKCS12_fp)(fp, p12);
-    } else {
-        return nullptr;
-    }
+    return ::d2i_PKCS12_fp(fp, p12);
 }
 
 int KOpenSSLProxy::PKCS12_newpass(PKCS12 *p12, char *oldpass, char *newpass)
 {
-    if (K_PKCS12_newpass) {
-        return (K_PKCS12_newpass)(p12, oldpass, newpass);
-    } else {
-        return -1;
-    }
+    return ::PKCS12_newpass(p12, oldpass, newpass);
 }
 
 int KOpenSSLProxy::i2d_PKCS12(PKCS12 *p12, unsigned char **p)
 {
-    if (K_i2d_PKCS12) {
-        return (K_i2d_PKCS12)(p12, p);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS12(p12, p);
 }
 
 int KOpenSSLProxy::i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)
 {
-    if (K_i2d_PKCS12_fp) {
-        return (K_i2d_PKCS12_fp)(fp, p12);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS12_fp(fp, p12);
 }
 
 PKCS12 *KOpenSSLProxy::PKCS12_new(void)
 {
-    if (K_PKCS12_new) {
-        return (K_PKCS12_new)();
-    } else {
-        return nullptr;
-    }
+    return ::PKCS12_new();
 }
 
 void KOpenSSLProxy::PKCS12_free(PKCS12 *a)
 {
-    if (K_PKCS12_free) {
-        (K_PKCS12_free)(a);
-    }
+    ::PKCS12_free(a);
 }
 
 int KOpenSSLProxy::PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey,
                                 X509 **cert, STACK_OF(X509) **ca)
 {
-    if (K_PKCS12_parse) {
-        return (K_PKCS12_parse)(p12, pass, pkey, cert, ca);
-    } else {
-        return -1;
-    }
+    return ::PKCS12_parse(p12, pass, pkey, cert, ca);
 }
 
 void KOpenSSLProxy::EVP_PKEY_free(EVP_PKEY *x)
 {
-    if (K_EVP_PKEY_free) {
-        (K_EVP_PKEY_free)(x);
-    }
+    ::EVP_PKEY_free(x);
 }
 
 EVP_PKEY *KOpenSSLProxy::EVP_PKEY_new()
 {
-    if (K_EVP_PKEY_new) {
-        return (K_EVP_PKEY_new)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_PKEY_new();
 }
 
 void KOpenSSLProxy::X509_REQ_free(X509_REQ *x)
 {
-    if (K_X509_REQ_free) {
-        (K_X509_REQ_free)(x);
-    }
+    ::X509_REQ_free(x);
 }
 
 X509_REQ *KOpenSSLProxy::X509_REQ_new()
 {
-    if (K_X509_REQ_new) {
-        return (K_X509_REQ_new)();
-    } else {
-        return nullptr;
-    }
+    return ::X509_REQ_new();
 }
 
 int KOpenSSLProxy::SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
 {
-    if (K_SSL_CTX_use_PrivateKey) {
-        return (K_SSL_CTX_use_PrivateKey)(ctx, pkey);
-    } else {
-        return -1;
-    }
+    return ::SSL_CTX_use_PrivateKey(ctx, pkey);
 }
 
 int KOpenSSLProxy::SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
 {
-    if (K_SSL_CTX_use_certificate) {
-        return (K_SSL_CTX_use_certificate)(ctx, x);
-    } else {
-        return -1;
-    }
+    return ::SSL_CTX_use_certificate(ctx, x);
 }
 
 int KOpenSSLProxy::SSL_get_error(SSL *ssl, int rc)
 {
-    if (K_SSL_get_error) {
-        return (K_SSL_get_error)(ssl, rc);
-    } else {
-        return -1;
-    }
+    return ::SSL_get_error(ssl, rc);
 }
 
 STACK_OF(X509) *KOpenSSLProxy::SSL_get_peer_cert_chain(SSL *s)
 {
-    if (K_SSL_get_peer_cert_chain) {
-        return (K_SSL_get_peer_cert_chain)(s);
-    } else {
-        return nullptr;
-    }
+    return ::SSL_get_peer_cert_chain(s);
 }
 
 void KOpenSSLProxy::sk_free(STACK *s)
 {
-    if (K_sk_free) {
-        (K_sk_free)(s);
-    }
+    ::OPENSSL_sk_free(s);
 }
 
 int KOpenSSLProxy::sk_num(STACK *s)
 {
-    if (K_sk_num) {
-        return (K_sk_num)(s);
-    } else {
-        return -1;
-    }
+    return ::OPENSSL_sk_num(s);
 }
 
 char *KOpenSSLProxy::sk_pop(STACK *s)
 {
-    if (K_sk_pop) {
-        return (K_sk_pop)(s);
-    } else {
-        return nullptr;
-    }
+    return static_cast<char*>(::OPENSSL_sk_pop(s));
 }
 
 char *KOpenSSLProxy::sk_value(STACK *s, int n)
 {
-    if (K_sk_value) {
-        return (K_sk_value)(s, n);
-    } else {
-        return nullptr;
-    }
+    return static_cast<char*>(::sk_value(s, n));
 }
 
 void KOpenSSLProxy::X509_STORE_CTX_set_chain(X509_STORE_CTX *v, STACK_OF(X509)* x)
 {
-    if (K_X509_STORE_CTX_set_chain) {
-        (K_X509_STORE_CTX_set_chain)(v, x);
-    }
+    ::X509_STORE_CTX_set_chain(v, x);
 }
 
 void KOpenSSLProxy::X509_STORE_CTX_set_purpose(X509_STORE_CTX *v, int purpose)
 {
-    if (K_X509_STORE_CTX_set_purpose) {
-        (K_X509_STORE_CTX_set_purpose)(v, purpose);
-    }
+    ::X509_STORE_CTX_set_purpose(v, purpose);
 }
 
 STACK *KOpenSSLProxy::sk_dup(STACK *s)
 {
-    if (K_sk_dup) {
-        return (K_sk_dup)(s);
-    } else {
-        return nullptr;
-    }
+    return ::sk_dup(s);
 }
 
-STACK *KOpenSSLProxy::sk_new(int (*cmp)())
+STACK *KOpenSSLProxy::sk_new(OPENSSL_sk_compfunc cmp)
 {
-    if (K_sk_new) {
-        return (K_sk_new)(cmp);
-    } else {
-        return nullptr;
-    }
+    return ::sk_new(cmp);
 }
 
 int KOpenSSLProxy::sk_push(STACK *s, char *d)
 {
-    if (K_sk_push) {
-        return (K_sk_push)(s, d);
-    } else {
-        return -1;
-    }
+    return ::sk_push(s, d);
 }
 
 char *KOpenSSLProxy::i2s_ASN1_INTEGER(X509V3_EXT_METHOD *meth, ASN1_INTEGER *aint)
 {
-    if (K_i2s_ASN1_INTEGER) {
-        return (K_i2s_ASN1_INTEGER)(meth, aint);
-    } else {
-        return nullptr;
-    }
+    return ::i2s_ASN1_INTEGER(meth, aint);
 }
 
 ASN1_INTEGER *KOpenSSLProxy::X509_get_serialNumber(X509 *x)
 {
-    if (K_X509_get_serialNumber) {
-        return (K_X509_get_serialNumber)(x);
-    } else {
-        return nullptr;
-    }
+    return ::X509_get_serialNumber(x);
 }
 
 EVP_PKEY *KOpenSSLProxy::X509_get_pubkey(X509 *x)
 {
-    if (K_X509_get_pubkey) {
-        return (K_X509_get_pubkey)(x);
-    } else {
-        return nullptr;
-    }
+    return ::X509_get_pubkey(x);
 }
 
 int KOpenSSLProxy::i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)
 {
-    if (K_i2d_PublicKey) {
-        return (K_i2d_PublicKey)(a, pp);
-    } else {
-        return 0;
-    }
+    return ::i2d_PublicKey(a, pp);
 }
 
 int KOpenSSLProxy::X509_check_private_key(X509 *x, EVP_PKEY *p)
 {
-    if (K_X509_check_private_key) {
-        return (K_X509_check_private_key)(x, p);
-    }
-    return -1;
+    return ::X509_check_private_key(x, p);
 }
 
 char *KOpenSSLProxy::BN_bn2hex(const BIGNUM *a)
 {
-    if (K_BN_bn2hex) {
-        return (K_BN_bn2hex)(a);
-    } else {
-        return nullptr;
-    }
+    return ::BN_bn2hex(a);
 }
 
 int KOpenSSLProxy::X509_digest(const X509 *x, const EVP_MD *t, unsigned char *md, unsigned int *len)
 {
-    if (K_X509_digest) {
-        return (K_X509_digest)(x, t, md, len);
-    } else {
-        return -1;
-    }
+    return ::X509_digest(x, t, md, len);
 }
 
-EVP_MD *KOpenSSLProxy::EVP_md5()
+const EVP_MD *KOpenSSLProxy::EVP_md5()
 {
-    if (K_EVP_md5) {
-        return (K_EVP_md5)();
-    }
-    return nullptr;
+    return ::EVP_md5();
 }
 
 void KOpenSSLProxy::ASN1_INTEGER_free(ASN1_INTEGER *a)
 {
-    if (K_ASN1_INTEGER_free) {
-        (K_ASN1_INTEGER_free)(a);
-    }
+    ::ASN1_INTEGER_free(a);
 }
 
 int KOpenSSLProxy::OBJ_obj2nid(ASN1_OBJECT *o)
 {
-    if (K_OBJ_obj2nid) {
-        return (K_OBJ_obj2nid)(o);
-    } else {
-        return -1;
-    }
+    return ::OBJ_obj2nid(o);
 }
 
 const char *KOpenSSLProxy::OBJ_nid2ln(int n)
 {
-    if (K_OBJ_nid2ln) {
-        return (K_OBJ_nid2ln)(n);
-    } else {
-        return nullptr;
-    }
+    return ::OBJ_nid2ln(n);
 }
 
 int KOpenSSLProxy::X509_get_ext_count(X509 *x)
 {
-    if (K_X509_get_ext_count) {
-        return (K_X509_get_ext_count)(x);
-    } else {
-        return -1;
-    }
+    return ::X509_get_ext_count(x);
 }
 
 int KOpenSSLProxy::X509_get_ext_by_NID(X509 *x, int nid, int lastpos)
 {
-    if (K_X509_get_ext_by_NID) {
-        return (K_X509_get_ext_by_NID)(x, nid, lastpos);
-    } else {
-        return -1;
-    }
+    return ::X509_get_ext_by_NID(x, nid, lastpos);
 }
 
 int KOpenSSLProxy::X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)
 {
-    if (K_X509_get_ext_by_OBJ) {
-        return (K_X509_get_ext_by_OBJ)(x, obj, lastpos);
-    } else {
-        return -1;
-    }
+    return ::X509_get_ext_by_OBJ(x, obj, lastpos);
 }
 
 X509_EXTENSION *KOpenSSLProxy::X509_get_ext(X509 *x, int loc)
 {
-    if (K_X509_get_ext) {
-        return (K_X509_get_ext)(x, loc);
-    } else {
-        return nullptr;
-    }
+    return ::X509_get_ext(x, loc);
 }
 
 X509_EXTENSION *KOpenSSLProxy::X509_delete_ext(X509 *x, int loc)
 {
-    if (K_X509_delete_ext) {
-        return (K_X509_delete_ext)(x, loc);
-    } else {
-        return nullptr;
-    }
+    return ::X509_delete_ext(x, loc);
 }
 
 int KOpenSSLProxy::X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)
 {
-    if (K_X509_add_ext) {
-        return (K_X509_add_ext)(x, ex, loc);
-    } else {
-        return -1;
-    }
+    return ::X509_add_ext(x, ex, loc);
 }
 
 void *KOpenSSLProxy::X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx)
 {
-    if (K_X509_get_ext_d2i) {
-        return (K_X509_get_ext_d2i)(x, nid, crit, idx);
-    } else {
-        return nullptr;
-    }
+    return ::X509_get_ext_d2i(x, nid, crit, idx);
 }
 
 char *KOpenSSLProxy::i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, ASN1_OCTET_STRING *ia5)
 {
-    if (K_i2s_ASN1_OCTET_STRING) {
-        return (K_i2s_ASN1_OCTET_STRING)(method, ia5);
-    } else {
-        return nullptr;
-    }
+    return ::i2s_ASN1_OCTET_STRING(method, ia5);
 }
 
 int KOpenSSLProxy::ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)
 {
-    if (K_ASN1_BIT_STRING_get_bit) {
-        return (K_ASN1_BIT_STRING_get_bit)(a, n);
-    } else {
-        return -1;
-    }
+    return ::ASN1_BIT_STRING_get_bit(a, n);
 }
 
 PKCS7 *KOpenSSLProxy::PKCS7_new(void)
 {
-    if (K_PKCS7_new) {
-        return (K_PKCS7_new)();
-    } else {
-        return nullptr;
-    }
+    return ::PKCS7_new();
 }
 
 void KOpenSSLProxy::PKCS7_free(PKCS7 *a)
 {
-    if (K_PKCS7_free) {
-        (K_PKCS7_free)(a);
-    }
+    ::PKCS7_free(a);
 }
 
 void KOpenSSLProxy::PKCS7_content_free(PKCS7 *a)
 {
-    if (K_PKCS7_content_free) {
-        (K_PKCS7_content_free)(a);
-    }
+    CRYPTO_free(a);
 }
 
 int KOpenSSLProxy::i2d_PKCS7(PKCS7 *a, unsigned char **pp)
 {
-    if (K_i2d_PKCS7) {
-        return (K_i2d_PKCS7)(a, pp);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS7(a, pp);
 }
 
-PKCS7 *KOpenSSLProxy::d2i_PKCS7(PKCS7 **a, unsigned char **pp, long length)
+PKCS7 *KOpenSSLProxy::d2i_PKCS7(PKCS7 **a, const unsigned char **pp, long length)
 {
-    if (K_d2i_PKCS7) {
-        return (K_d2i_PKCS7)(a, pp, length);
-    } else {
-        return nullptr;
-    }
+    return ::d2i_PKCS7(a, pp, length);
 }
 
 int KOpenSSLProxy::i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)
 {
-    if (K_i2d_PKCS7_fp) {
-        return (K_i2d_PKCS7_fp)(fp, p7);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS7_fp(fp, p7);
 }
 
 PKCS7 *KOpenSSLProxy::d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)
 {
-    if (K_d2i_PKCS7_fp) {
-        return (K_d2i_PKCS7_fp)(fp, p7);
-    } else {
-        return nullptr;
-    }
+    return ::d2i_PKCS7_fp(fp, p7);
 }
 
 int KOpenSSLProxy::i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)
 {
-    if (K_i2d_PKCS7_bio) {
-        return (K_i2d_PKCS7_bio)(bp, p7);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS7_bio(bp, p7);
 }
 
 PKCS7 *KOpenSSLProxy::d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)
 {
-    if (K_d2i_PKCS7_bio) {
-        return (K_d2i_PKCS7_bio)(bp, p7);
-    } else {
-        return nullptr;
-    }
+    return ::d2i_PKCS7_bio(bp, p7);
 }
 
 PKCS7 *KOpenSSLProxy::PKCS7_dup(PKCS7 *p7)
 {
-    if (K_PKCS7_dup) {
-        return (K_PKCS7_dup)(p7);
-    } else {
-        return nullptr;
-    }
+    return ::PKCS7_dup(p7);
 }
 
 PKCS7 *KOpenSSLProxy::PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,
                                  BIO *data, int flags)
 {
-    if (K_PKCS7_sign) {
-        return (K_PKCS7_sign)(signcert, pkey, certs, data, flags);
-    } else {
-        return nullptr;
-    }
+    return ::PKCS7_sign(signcert, pkey, certs, data, flags);
 }
 
 int KOpenSSLProxy::PKCS7_verify(PKCS7 *p, STACK_OF(X509)* st, X509_STORE *s, BIO *in, BIO *out, int flags)
 {
-    if (K_PKCS7_verify) {
-        return (K_PKCS7_verify)(p, st, s, in, out, flags);
-    } else {
-        return 0;
-    }
+    return ::PKCS7_verify(p, st, s, in, out, flags);
 }
 
 STACK_OF(X509) *KOpenSSLProxy::PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs, int flags)
 {
-    if (K_PKCS7_get0_signers) {
-        return (K_PKCS7_get0_signers)(p7, certs, flags);
-    } else {
-        return nullptr;
-    }
+    return ::PKCS7_get0_signers(p7, certs, flags);
 }
 
 PKCS7 *KOpenSSLProxy::PKCS7_encrypt(STACK_OF(X509) *certs, BIO *in, EVP_CIPHER *cipher,
                                     int flags)
 {
-    if (K_PKCS7_encrypt) {
-        return (K_PKCS7_encrypt)(certs, in, cipher, flags);
-    } else {
-        return nullptr;
-    }
+    return ::PKCS7_encrypt(certs, in, cipher, flags);
 }
 
 int KOpenSSLProxy::PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
 {
-    if (K_PKCS7_decrypt) {
-        return (K_PKCS7_decrypt)(p7, pkey, cert, data, flags);
-    } else {
-        return 0;
-    }
+    return ::PKCS7_decrypt(p7, pkey, cert, data, flags);
 }
 
 STACK_OF(X509_NAME) *KOpenSSLProxy::SSL_load_client_CA_file(const char *file)
 {
-    if (K_SSL_load_client_CA_file) {
-        return (K_SSL_load_client_CA_file)(file);
-    } else {
-        return nullptr;
-    }
+    return ::SSL_load_client_CA_file(file);
 }
 
 STACK_OF(X509_INFO) *KOpenSSLProxy::PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
 {
-    if (K_PEM_X509_INFO_read) {
-        return (K_PEM_X509_INFO_read)(fp, sk, cb, u);
-    } else {
-        return nullptr;
-    }
+    return ::PEM_X509_INFO_read(fp, sk, cb, u);
 }
 
 X509 *KOpenSSLProxy::X509_d2i_fp(FILE *out, X509 **buf)
 {
-    if (K_ASN1_d2i_fp) {
-        return reinterpret_cast<X509 *>((K_ASN1_d2i_fp)(reinterpret_cast<char *(*)()>(K_X509_new), reinterpret_cast<char *(*)()>(K_d2i_X509), out, reinterpret_cast<unsigned char **>(buf)));
-    } else {
-        return nullptr;
-    }
+        return reinterpret_cast<X509 *>(::ASN1_d2i_fp(reinterpret_cast<void *(*)()>(::X509_new), reinterpret_cast<d2i_of_void*>(::d2i_X509), out, reinterpret_cast<void **>(buf)));
 }
 
 int KOpenSSLProxy::SSL_peek(SSL *ssl, void *buf, int num)
 {
-    if (K_SSL_peek) {
-        return (K_SSL_peek)(ssl, buf, num);
-    } else {
-        return -1;
-    }
+    return ::SSL_peek(ssl, buf, num);
 }
 
 const char *KOpenSSLProxy::RAND_file_name(char *buf, size_t num)
 {
-    if (K_RAND_file_name) {
-        return (K_RAND_file_name)(buf, num);
-    } else {
-        return nullptr;
-    }
+    return ::RAND_file_name(buf, num);
 }
 
 int KOpenSSLProxy::RAND_load_file(const char *filename, long max_bytes)
 {
-    if (K_RAND_load_file) {
-        return (K_RAND_load_file)(filename, max_bytes);
-    } else {
-        return -1;
-    }
+    return ::RAND_load_file(filename, max_bytes);
 }
 
 int KOpenSSLProxy::RAND_write_file(const char *filename)
 {
-    if (K_RAND_write_file) {
-        return (K_RAND_write_file)(filename);
-    } else {
-        return -1;
-    }
+    return ::RAND_write_file(filename);
 }
 
 int KOpenSSLProxy::X509_PURPOSE_get_count()
 {
-    if (K_X509_PURPOSE_get_count) {
-        return (K_X509_PURPOSE_get_count)();
-    } else {
-        return -1;
-    }
+    return ::X509_PURPOSE_get_count();
 }
 
 int KOpenSSLProxy::X509_PURPOSE_get_id(X509_PURPOSE *p)
 {
-    if (K_X509_PURPOSE_get_id) {
-        return (K_X509_PURPOSE_get_id)(p);
-    } else {
-        return -1;
-    }
+    return ::X509_PURPOSE_get_id(p);
 }
 
 int KOpenSSLProxy::X509_check_purpose(X509 *x, int id, int ca)
 {
-    if (K_X509_check_purpose) {
-        return (K_X509_check_purpose)(x, id, ca);
-    } else {
-        return -1;
-    }
+    return ::X509_check_purpose(x, id, ca);
 }
 
 X509_PURPOSE *KOpenSSLProxy::X509_PURPOSE_get0(int idx)
 {
-    if (K_X509_PURPOSE_get0) {
-        return (K_X509_PURPOSE_get0)(idx);
-    } else {
-        return nullptr;
-    }
+    return ::X509_PURPOSE_get0(idx);
 }
 
 int KOpenSSLProxy::EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)
 {
-    if (K_EVP_PKEY_assign) {
-        return (K_EVP_PKEY_assign)(pkey, type, key);
-    } else {
-        return -1;
-    }
+    return ::EVP_PKEY_assign(pkey, type, key);
 }
 
 int KOpenSSLProxy::X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)
 {
-    if (K_X509_REQ_set_pubkey) {
-        return (K_X509_REQ_set_pubkey)(x, pkey);
-    } else {
-        return -1;
-    }
+    return ::X509_REQ_set_pubkey(x, pkey);
 }
 
 RSA *KOpenSSLProxy::RSA_generate_key(int bits, unsigned long e, void
                                      (*callback)(int, int, void *), void *cb_arg)
 {
-    if (K_RSA_generate_key) {
-        return (K_RSA_generate_key)(bits, e, callback, cb_arg);
-    } else {
-        return nullptr;
-    }
+    return ::RSA_generate_key(bits, e, callback, cb_arg);
 }
 
 STACK *KOpenSSLProxy::X509_get1_email(X509 *x)
 {
-    if (K_X509_get1_email) {
-        return (K_X509_get1_email)(x);
-    } else {
-        return nullptr;
-    }
+    return reinterpret_cast<STACK*>(::X509_get1_email(x));
 }
 
 void KOpenSSLProxy::X509_email_free(STACK *sk)
 {
-    if (K_X509_email_free) {
-        (K_X509_email_free)(sk);
-    }
+    ::X509_email_free(reinterpret_cast<STACK_OF(OPENSSL_STRING)*>(sk));
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_des_ede3_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_des_ede3_cbc()
 {
-    if (K_EVP_des_ede3_cbc) {
-        return (K_EVP_des_ede3_cbc)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_des_ede3_cbc();
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_des_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_des_cbc()
 {
-    if (K_EVP_des_cbc) {
-        return (K_EVP_des_cbc)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_des_cbc();
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_rc2_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_rc2_cbc()
 {
-    if (K_EVP_rc2_cbc) {
-        return (K_EVP_rc2_cbc)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_rc2_cbc();
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_rc2_64_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_rc2_64_cbc()
 {
-    if (K_EVP_rc2_64_cbc) {
-        return (K_EVP_rc2_64_cbc)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_rc2_64_cbc();
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_rc2_40_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_rc2_40_cbc()
 {
-    if (K_EVP_rc2_40_cbc) {
-        return (K_EVP_rc2_40_cbc)();
-    } else {
-        return nullptr;
-    }
+    return ::EVP_rc2_40_cbc();
 }
 
 int KOpenSSLProxy::i2d_X509_REQ_fp(FILE *fp, X509_REQ *x)
 {
-    if (K_i2d_X509_REQ_fp) {
-        return (K_i2d_X509_REQ_fp)(fp, x);
-    } else {
-        return -1;
-    }
+    return ::i2d_X509_REQ_fp(fp, x);
 }
 
 void KOpenSSLProxy::ERR_clear_error()
 {
-    if (K_ERR_clear_error) {
-        (K_ERR_clear_error)();
-    }
+    return ::ERR_clear_error();
 }
 
 unsigned long KOpenSSLProxy::ERR_get_error()
 {
-    if (K_ERR_get_error) {
-        return (K_ERR_get_error)();
-    } else {
-        return 0xffffffff;
-    }
+    return ::ERR_get_error();
 }
 
 void KOpenSSLProxy::ERR_print_errors_fp(FILE *fp)
 {
-    if (K_ERR_print_errors_fp) {
-        (K_ERR_print_errors_fp)(fp);
-    }
+    return ::ERR_print_errors_fp(fp);
 }
 
 SSL_SESSION *KOpenSSLProxy::SSL_get1_session(SSL *ssl)
 {
-    if (K_SSL_get1_session) {
-        return (K_SSL_get1_session)(ssl);
-    } else {
-        return nullptr;
-    }
+    return ::SSL_get1_session(ssl);
 }
 
 void KOpenSSLProxy::SSL_SESSION_free(SSL_SESSION *session)
 {
-    if (K_SSL_SESSION_free) {
-        (K_SSL_SESSION_free)(session);
-    }
+    return ::SSL_SESSION_free(session);
 }
 
 int KOpenSSLProxy::SSL_set_session(SSL *ssl, SSL_SESSION *session)
 {
-    if (K_SSL_set_session) {
-        return (K_SSL_set_session)(ssl, session);
-    } else {
-        return -1;
-    }
+    return ::SSL_set_session(ssl, session);
 }
 
-SSL_SESSION *KOpenSSLProxy::d2i_SSL_SESSION(SSL_SESSION **a, unsigned char **pp, long length)
+SSL_SESSION *KOpenSSLProxy::d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length)
 {
-    if (K_d2i_SSL_SESSION) {
-        return (K_d2i_SSL_SESSION)(a, pp, length);
-    } else {
-        return nullptr;
-    }
+    return ::d2i_SSL_SESSION(a, pp, length);
 }
 
 int KOpenSSLProxy::i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)
 {
-    if (K_i2d_SSL_SESSION) {
-        return (K_i2d_SSL_SESSION)(in, pp);
-    } else {
-        return -1;
-    }
+    return ::i2d_SSL_SESSION(in, pp);
 }
 
 int KOpenSSLProxy::i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *p)
 {
-    if (K_i2d_PrivateKey_fp) {
-        return (K_i2d_PrivateKey_fp)(fp, p);
-    } else {
-        return -1;
-    }
+    return ::i2d_PrivateKey_fp(fp, p);
 }
 
 int KOpenSSLProxy::i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *p, const EVP_CIPHER *c, char *k, int klen, pem_password_cb *cb, void *u)
 {
-    if (K_i2d_PKCS8PrivateKey_fp) {
-        return (K_i2d_PKCS8PrivateKey_fp)(fp, p, c, k, klen, cb, u);
-    } else {
-        return -1;
-    }
+    return ::i2d_PKCS8PrivateKey_fp(fp, p, c, k, klen, cb, u);
 }
 
 void KOpenSSLProxy::RSA_free(RSA *rsa)
 {
-    if (K_RSA_free) {
-        (K_RSA_free)(rsa);
-    }
+    return ::RSA_free(rsa);
 }
 
-EVP_CIPHER *KOpenSSLProxy::EVP_bf_cbc()
+const EVP_CIPHER *KOpenSSLProxy::EVP_bf_cbc()
 {
-    if (K_EVP_bf_cbc) {
-        return (K_EVP_bf_cbc)();
-    }
-    return nullptr;
+    return ::EVP_bf_cbc();
 }
 
 int KOpenSSLProxy::X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
 {
-    if (K_X509_REQ_sign) {
-        return (K_X509_REQ_sign)(x, pkey, md);
-    }
-    return -1;
+    return ::X509_REQ_sign(x, pkey, md);
 }
 
 int KOpenSSLProxy::X509_NAME_add_entry_by_txt(X509_NAME *name, char *field,
         int type, unsigned char *bytes, int len, int loc, int set)
 {
-    if (K_X509_NAME_add_entry_by_txt) {
-        return (K_X509_NAME_add_entry_by_txt)(name, field, type, bytes, len, loc, set);
-    }
-    return -1;
+    return ::X509_NAME_add_entry_by_txt(name, field, type, bytes, len, loc, set);
 }
 
 X509_NAME *KOpenSSLProxy::X509_NAME_new()
 {
-    if (K_X509_NAME_new) {
-        return (K_X509_NAME_new)();
-    }
-    return nullptr;
+    return ::X509_NAME_new();
 }
 
 int KOpenSSLProxy::X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name)
 {
-    if (K_X509_REQ_set_subject_name) {
-        return (K_X509_REQ_set_subject_name)(req, name);
-    }
-    return -1;
+    return ::X509_REQ_set_subject_name(req, name);
 }
 
 unsigned char *KOpenSSLProxy::ASN1_STRING_data(ASN1_STRING *x)
 {
-    if (K_ASN1_STRING_data) {
-        return (K_ASN1_STRING_data)(x);
-    }
-    return nullptr;
+    return ::ASN1_STRING_data(x);
 }
 
 int KOpenSSLProxy::ASN1_STRING_length(ASN1_STRING *x)
 {
-    if (K_ASN1_STRING_length) {
-        return (K_ASN1_STRING_length)(x);
-    }
-    return 0L;
+    return ::ASN1_STRING_length(x);
 }
 
 STACK_OF(SSL_CIPHER) *KOpenSSLProxy::SSL_get_ciphers(const SSL *ssl)
 {
-    if (K_SSL_get_ciphers) {
-        return (K_SSL_get_ciphers)(ssl);
-    }
-    return nullptr;
+    return ::SSL_get_ciphers(ssl);
 }
 
 #endif
-
--- kdelibs4support-5.32.0/src/kssl/kopenssl.h.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/kopenssl.h	2017-03-24 14:53:43.108091825 +0100
@@ -131,7 +131,7 @@ public:
     /*
      *   SSL_CTX_new - create a new SSL_CTX object as framework for TLS/SSL enabled functions
      */
-    SSL_CTX *SSL_CTX_new(SSL_METHOD *method);
+    SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);
 
     /*
      *   SSL_CTX_free - free an allocated SSL_CTX object
@@ -172,7 +172,7 @@ public:
     /*
      *   SSL_get_current_cipher - get SSL_CIPHER of a connection
      */
-    SSL_CIPHER *SSL_get_current_cipher(SSL *ssl);
+    const SSL_CIPHER *SSL_get_current_cipher(SSL *ssl);
 
     /*
      *   SSL_set_options - manipulate SSL engine options
@@ -209,12 +209,12 @@ public:
     /*
      *   TLSv1_client_method - return a TLSv1 client method object
      */
-    SSL_METHOD *TLSv1_client_method();
+    const SSL_METHOD *TLSv1_client_method();
 
     /*
      *   SSLv23_client_method - return a SSLv23 client method object
      */
-    SSL_METHOD *SSLv23_client_method();
+    const SSL_METHOD *SSLv23_client_method();
 
     /*
      *   SSL_get_peer_certificate - return the peer's certificate
@@ -234,7 +234,7 @@ public:
     /*
      *   SSL_CIPHER_get_version - get the version of this cipher
      */
-    char *SSL_CIPHER_get_version(SSL_CIPHER *c);
+    const char *SSL_CIPHER_get_version(SSL_CIPHER *c);
 
     /*
      *   SSL_CIPHER_get_name - get the name of this cipher
@@ -260,7 +260,7 @@ public:
     /*
      *   d2i_X509 - Convert a text representation of X509 to an X509 object
      */
-    X509 *d2i_X509(X509 **a, unsigned char **pp, long length);
+    X509 *d2i_X509(X509 **a, const unsigned char **pp, long length);
 
     /*
      *   i2d_X509 - Convert an X509 object into a text representation
@@ -370,7 +370,7 @@ public:
     /*
      *   BIO methods - only one defined here yet
      */
-    BIO_METHOD *BIO_s_mem(void);
+    const BIO_METHOD *BIO_s_mem(void);
 
     /*
      *   BIO_new_fp - nastiness called BIO - used to create BIO* from FILE*
@@ -403,11 +403,6 @@ public:
     int PEM_write_bio_X509(BIO *bp, X509 *x);
 
     /*
-     *   ASN1_item_i2d_fp - used for netscape output
-     */
-    int ASN1_item_i2d_fp(FILE *out, unsigned char *x);
-
-    /*
      *   ASN1_d2i_fp - read an X509 from a DER encoded file (buf can be NULL)
      */
     X509 *X509_d2i_fp(FILE *out, X509 **buf);
@@ -495,7 +490,7 @@ public:
     /*
      *  Create a new stack
      */
-    STACK *sk_new(int (*cmp)());
+    STACK *sk_new(OPENSSL_sk_compfunc cmp);
 
     /*
      *  Add an element to the stack
@@ -552,7 +547,7 @@ public:
     /*
      *  EVP_md5
      */
-    EVP_MD *EVP_md5();
+    const EVP_MD *EVP_md5();
 
     /*
      *  ASN1_INTEGER free
@@ -647,7 +642,7 @@ public:
     /*
      *
      */
-    PKCS7 *d2i_PKCS7(PKCS7 **a, unsigned char **pp, long length);
+    PKCS7 *d2i_PKCS7(PKCS7 **a, const unsigned char **pp, long length);
 
     /*
      *
@@ -768,11 +763,11 @@ public:
     void X509_email_free(STACK *sk);
 
     /* Ciphers needed for SMime */
-    EVP_CIPHER *EVP_des_ede3_cbc();
-    EVP_CIPHER *EVP_des_cbc();
-    EVP_CIPHER *EVP_rc2_cbc();
-    EVP_CIPHER *EVP_rc2_64_cbc();
-    EVP_CIPHER *EVP_rc2_40_cbc();
+    const EVP_CIPHER *EVP_des_ede3_cbc();
+    const EVP_CIPHER *EVP_des_cbc();
+    const EVP_CIPHER *EVP_rc2_cbc();
+    const EVP_CIPHER *EVP_rc2_64_cbc();
+    const EVP_CIPHER *EVP_rc2_40_cbc();
 
     /* clear the current error  - use this often*/
     void ERR_clear_error();
@@ -793,7 +788,7 @@ public:
     int SSL_set_session(SSL *ssl, SSL_SESSION *session);
 
     /* Decode ASN.1 to SSL_SESSION */
-    SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, unsigned char **pp, long length);
+    SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length);
     /* Encode SSL_SESSION to ASN.1 */
     int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);
 
@@ -807,7 +802,7 @@ public:
     void RSA_free(RSA *);
 
     /* Get a blowfish CBC pointer */
-    EVP_CIPHER *EVP_bf_cbc();
+    const EVP_CIPHER *EVP_bf_cbc();
 
     /* Sign a CSR */
     int X509_REQ_sign(X509_REQ *, EVP_PKEY *, const EVP_MD *);
--- kdelibs4support-5.32.0/src/kssl/ksslcallback.c.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/ksslcallback.c	2017-03-24 14:53:43.108091825 +0100
@@ -39,7 +39,7 @@ extern "C" {
         // back will not be threadsafe ofcourse.
 
         if (KSSL_X509CallBack_ca) {
-            if (KOSSL::self()->X509_cmp(ctx->current_cert, KSSL_X509CallBack_ca) != 0) {
+            if (KOSSL::self()->X509_cmp(X509_STORE_CTX_get0_cert(ctx), KSSL_X509CallBack_ca) != 0) {
                 return 1;    // Ignore errors for this certificate
             }
 
@@ -47,7 +47,7 @@ extern "C" {
         }
 
         if (!ok) {
-            switch (ctx->error) {
+            switch (X509_STORE_CTX_get_error(ctx)) {
             case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
             case X509_V_ERR_UNABLE_TO_GET_CRL:
             case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:
--- kdelibs4support-5.32.0/src/kssl/ksslcertchain.cpp.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/ksslcertchain.cpp	2017-03-24 14:53:43.108091825 +0100
@@ -41,16 +41,6 @@
 #include <kopenssl.h>
 #include <QtCore/QStringList>
 
-#if KSSL_HAVE_SSL
-#define sk_new d->kossl->sk_new
-#define sk_push d->kossl->sk_push
-#define sk_free d->kossl->sk_free
-#define sk_value d->kossl->sk_value
-#define sk_num d->kossl->sk_num
-#define sk_dup d->kossl->sk_dup
-#define sk_pop d->kossl->sk_pop
-#endif
-
 class KSSLCertChainPrivate
 {
 public:
--- kdelibs4support-5.32.0/src/kssl/ksslcertificate.cpp.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/ksslcertificate.cpp	2017-03-24 14:59:42.598253378 +0100
@@ -146,7 +146,7 @@ KSSLCertificate *KSSLCertificate::fromSt
     }
 
     QByteArray qba = QByteArray::fromBase64(cert);
-    unsigned char *qbap = reinterpret_cast<unsigned char *>(qba.data());
+    const unsigned char *qbap = reinterpret_cast<unsigned char *>(qba.data());
     X509 *x5c = KOSSL::self()->d2i_X509(nullptr, &qbap, qba.size());
     if (!x5c) {
         return nullptr;
@@ -168,7 +168,7 @@ QString KSSLCertificate::getSubject() co
         return rc;
     }
     rc = t;
-    d->kossl->OPENSSL_free(t);
+    OPENSSL_free(t);
 #endif
     return rc;
 }
@@ -195,14 +195,26 @@ QString KSSLCertificate::getSignatureTex
     char *s;
     int n, i;
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     i = d->kossl->OBJ_obj2nid(d->m_cert->sig_alg->algorithm);
+#else
+    i = X509_get_signature_nid(d->m_cert);
+#endif
     rc = i18n("Signature Algorithm: ");
     rc += (i == NID_undef) ? i18n("Unknown") : QString(d->kossl->OBJ_nid2ln(i));
-
     rc += '\n';
+
     rc += i18n("Signature Contents:");
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     n = d->m_cert->signature->length;
     s = (char *)d->m_cert->signature->data;
+#else
+    const ASN1_BIT_STRING *sig;
+    const X509_ALGOR *alg;
+    X509_get0_signature(&sig, &alg, d->m_cert);
+    n = sig->length;
+    s = (char*)sig->data;
+#endif
     for (i = 0; i < n; ++i) {
         if (i % 20 != 0) {
             rc += ':';
@@ -228,7 +240,7 @@ void KSSLCertificate::getEmails(QStringL
 
     STACK *s = d->kossl->X509_get1_email(d->m_cert);
     if (s) {
-        for (int n = 0; n < s->num; n++) {
+        for (int n = 0; n < OPENSSL_sk_num(s); n++) {
             to.append(d->kossl->sk_value(s, n));
         }
         d->kossl->X509_email_free(s);
@@ -309,12 +321,12 @@ QString KSSLCertificate::getKeyType() co
     EVP_PKEY *pkey = d->kossl->X509_get_pubkey(d->m_cert);
     if (pkey) {
 #ifndef NO_RSA
-        if (pkey->type == EVP_PKEY_RSA) {
+        if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA) {
             rc = "RSA";
         } else
 #endif
 #ifndef NO_DSA
-            if (pkey->type == EVP_PKEY_DSA) {
+            if (EVP_PKEY_id(pkey) == EVP_PKEY_DSA) {
                 rc = "DSA";
             } else
 #endif
@@ -336,8 +348,10 @@ QString KSSLCertificate::getPublicKeyTex
     if (pkey) {
         rc = i18nc("Unknown", "Unknown key algorithm");
 #ifndef NO_RSA
-        if (pkey->type == EVP_PKEY_RSA) {
-            x = d->kossl->BN_bn2hex(pkey->pkey.rsa->n);
+        if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA) {
+	    const BIGNUM *n, *e, *dd;
+	    RSA_get0_key(EVP_PKEY_get1_RSA(pkey), &n, &e, &dd);
+            x = d->kossl->BN_bn2hex(n);
             rc = i18n("Key type: RSA (%1 bit)", strlen(x) * 4) + '\n';
 
             rc += i18n("Modulus: ");
@@ -350,17 +364,19 @@ QString KSSLCertificate::getPublicKeyTex
                 rc += x[i];
             }
             rc += '\n';
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
 
-            x = d->kossl->BN_bn2hex(pkey->pkey.rsa->e);
+            x = d->kossl->BN_bn2hex(e);
             rc += i18n("Exponent: 0x") + QLatin1String(x) +
                   QLatin1String("\n");
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
         }
 #endif
 #ifndef NO_DSA
-        if (pkey->type == EVP_PKEY_DSA) {
-            x = d->kossl->BN_bn2hex(pkey->pkey.dsa->p);
+        if (EVP_PKEY_id(pkey) == EVP_PKEY_DSA) {
+            const BIGNUM *p, *q, *g;
+	    DSA_get0_pqg(EVP_PKEY_get1_DSA(pkey), &p, &q, &g);
+            x = d->kossl->BN_bn2hex(p);
             // hack - this may not be always accurate
             rc = i18n("Key type: DSA (%1 bit)", strlen(x) * 4) + '\n';
 
@@ -374,9 +390,9 @@ QString KSSLCertificate::getPublicKeyTex
                 rc += x[i];
             }
             rc += '\n';
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
 
-            x = d->kossl->BN_bn2hex(pkey->pkey.dsa->q);
+            x = d->kossl->BN_bn2hex(q);
             rc += i18n("160 bit prime factor: ");
             for (unsigned int i = 0; i < strlen(x); i++) {
                 if (i % 40 != 0 && i % 2 == 0) {
@@ -387,9 +403,9 @@ QString KSSLCertificate::getPublicKeyTex
                 rc += x[i];
             }
             rc += '\n';
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
 
-            x = d->kossl->BN_bn2hex(pkey->pkey.dsa->g);
+            x = d->kossl->BN_bn2hex(g);
             rc += QString("g: ");
             for (unsigned int i = 0; i < strlen(x); i++) {
                 if (i % 40 != 0 && i % 2 == 0) {
@@ -400,9 +416,11 @@ QString KSSLCertificate::getPublicKeyTex
                 rc += x[i];
             }
             rc += '\n';
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
 
-            x = d->kossl->BN_bn2hex(pkey->pkey.dsa->pub_key);
+	    const BIGNUM *pub, *priv;
+	    DSA_get0_key(EVP_PKEY_get1_DSA(pkey), &pub, &priv);
+            x = d->kossl->BN_bn2hex(pub);
             rc += i18n("Public key: ");
             for (unsigned int i = 0; i < strlen(x); i++) {
                 if (i % 40 != 0 && i % 2 == 0) {
@@ -413,7 +431,7 @@ QString KSSLCertificate::getPublicKeyTex
                 rc += x[i];
             }
             rc += '\n';
-            d->kossl->OPENSSL_free(x);
+            OPENSSL_free(x);
         }
 #endif
         d->kossl->EVP_PKEY_free(pkey);
@@ -435,7 +453,7 @@ QString KSSLCertificate::getIssuer() con
     }
 
     rc = t;
-    d->kossl->OPENSSL_free(t);
+    OPENSSL_free(t);
 #endif
 
     return rc;
@@ -733,9 +751,9 @@ KSSLCertificate::KSSLValidationList KSSL
         KSSL_X509CallBack_ca = ca ? ca->d->m_cert : nullptr;
         KSSL_X509CallBack_ca_found = false;
 
-        certStoreCTX->error = X509_V_OK;
+        X509_STORE_CTX_set_error(certStoreCTX, X509_V_OK);
         rc = d->kossl->X509_verify_cert(certStoreCTX);
-        int errcode = certStoreCTX->error;
+        int errcode = X509_STORE_CTX_get_error(certStoreCTX);
         if (ca && !KSSL_X509CallBack_ca_found) {
             ksslv = KSSLCertificate::Irrelevant;
         } else {
@@ -748,9 +766,9 @@ KSSLCertificate::KSSLValidationList KSSL
             d->kossl->X509_STORE_CTX_set_purpose(certStoreCTX,
                                                  X509_PURPOSE_NS_SSL_SERVER);
 
-            certStoreCTX->error = X509_V_OK;
+            X509_STORE_CTX_set_error(certStoreCTX, X509_V_OK);
             rc = d->kossl->X509_verify_cert(certStoreCTX);
-            errcode = certStoreCTX->error;
+            errcode = X509_STORE_CTX_get_error(certStoreCTX);
             ksslv = processError(errcode);
         }
         d->kossl->X509_STORE_CTX_free(certStoreCTX);
@@ -1210,7 +1228,7 @@ typedef struct NETSCAPE_X509_st {
 QByteArray KSSLCertificate::toNetscape()
 {
     QByteArray qba;
-#if KSSL_HAVE_SSL
+#if KSSL_HAVE_SSL && OPENSSL_VERSION_NUMBER < 0x1010000L
     NETSCAPE_X509 nx;
     ASN1_OCTET_STRING hdr;
     QTemporaryFile ktf;
@@ -1263,7 +1281,7 @@ bool KSSLCertificate::setCert(const QStr
 #if KSSL_HAVE_SSL
     QByteArray qba, qbb = cert.toLocal8Bit();
     qba = QByteArray::fromBase64(qbb);
-    unsigned char *qbap = reinterpret_cast<unsigned char *>(qba.data());
+    const unsigned char *qbap = reinterpret_cast<unsigned char *>(qba.data());
     X509 *x5c = KOSSL::self()->d2i_X509(nullptr, &qbap, qba.size());
     if (x5c) {
         setCert(x5c);
@@ -1294,7 +1312,7 @@ QStringList KSSLCertificate::subjAltName
         return rc;
     }
 
-    int cnt = d->kossl->sk_GENERAL_NAME_num(names);
+    int cnt = sk_GENERAL_NAME_num(names);
 
     for (int i = 0; i < cnt; i++) {
         const GENERAL_NAME *val = (const GENERAL_NAME *)d->kossl->sk_value(names, i);
--- kdelibs4support-5.32.0/src/kssl/kssl.cpp.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/kssl.cpp	2017-03-24 14:53:43.109091802 +0100
@@ -61,7 +61,7 @@ public:
 #if KSSL_HAVE_SSL
     SSL *m_ssl;
     SSL_CTX *m_ctx;
-    SSL_METHOD *m_meth;
+    const SSL_METHOD *m_meth;
 #endif
     KOSSL *kossl;
 };
--- kdelibs4support-5.32.0/src/kssl/ksslutils.cpp.0000~	2017-03-04 17:10:46.000000000 +0100
+++ kdelibs4support-5.32.0/src/kssl/ksslutils.cpp	2017-03-24 14:53:43.109091802 +0100
@@ -94,9 +94,9 @@ QString ASN1_UTCTIME_QString(ASN1_UTCTIM
 
 QString ASN1_INTEGER_QString(ASN1_INTEGER *aint)
 {
-    char *rep = KOSSL::self()->i2s_ASN1_INTEGER(nullptr, aint);
+    char *rep = KOSSL::self()->i2s_ASN1_INTEGER(NULL, aint);
     QString yy = rep;
-    KOSSL::self()->OPENSSL_free(rep);
+    OPENSSL_free(rep);
     return yy;
 }
 
